pub fn register_auto_resource_bindings (registry : & bevy_lua_ecs :: LuaResourceRegistry) { } # [doc = r" Auto-discovered entity wrapper type names (for runtime TypeRegistry lookup)"] # [doc = r" These are type names discovered by scanning bevy_* crates for:"] # [doc = r" `pub struct TypeName(pub Entity)` with `#[derive(Component)]`"] pub const DISCOVERED_ENTITY_WRAPPERS : & [& str] = & ["ChildOf" , "Children" , "TiledColliderOf" , "TiledColliders" , "TiledMapReference" , "TiledObjectVisualOf" , "TiledObjectVisuals" , "BindingOf" , "Bindings" , "XrHandBoneEntities" , "LightViewEntities" , "RenderEntity" , "MainEntity" , "OcclusionCullingSubviewEntities" , "ParentSync" , "ClientEntityMap" , "PriorityMap" , "TargetCamera" , "UiTargetCamera" , "UiCameraView" , "UiViewTarget"] ; # [doc = r" Register entity wrapper components at runtime using TypeRegistry"] # [doc = r" This looks up each discovered type name in the registry and registers"] # [doc = r" a handler if it's a valid entity wrapper component"] pub fn register_entity_wrappers_from_registry (component_registry : & mut bevy_lua_ecs :: ComponentRegistry , type_registry : & bevy :: ecs :: reflect :: AppTypeRegistry ,) { bevy_lua_ecs :: register_entity_wrappers_runtime (component_registry , type_registry , DISCOVERED_ENTITY_WRAPPERS ,) ; } pub fn register_auto_constructors (lua : & mlua :: Lua) -> Result < () , mlua :: Error > { Ok (()) } # [doc = r" Register all discovered bitflags types with the BitflagsRegistry"] # [doc = r" Call this in your app's Startup systems to enable generic bitflags handling"] # [doc = r" Generated from types discovered during asset constructor parsing"] pub fn register_auto_bitflags (registry : & bevy_lua_ecs :: BitflagsRegistry) { registry . register ("TextureUsages" , & [("COPY_SRC" , 1u32) , ("COPY_DST" , 2u32) , ("TEXTURE_BINDING" , 4u32) , ("STORAGE_BINDING" , 8u32) , ("RENDER_ATTACHMENT" , 16u32)]) ; } # [doc = r" Auto-discovered asset type names (for runtime TypeRegistry lookup)"] # [doc = r" These are type names discovered by scanning bevy_* crates for:"] # [doc = r" `impl Asset for TypeName` or `#[derive(Asset)] struct TypeName`"] pub const DISCOVERED_ASSET_TYPES : & [& str] = & ["AnimationClip" , "AnimationGraph" , "LoadedUntypedAsset" , "LoadedFolder" , "AudioSource" , "Pitch" , "AutoExposureCompensationCurve" , "TiledMapAsset" , "TiledWorldAsset" , "TiledMap" , "TiledWorld" , "StandardTilemapMaterial" , "LineGizmo" , "GizmoAsset" , "GltfNode" , "Gltf" , "GltfMesh" , "GltfPrimitive" , "GltfSkin" , "Image" , "TextureAtlasLayout" , "Mesh" , "SkinnedMeshInverseBindposes" , "ExtendedMaterial" , "StandardMaterial" , "WireframeMaterial" , "ForwardDecalMaterialExt" , "MeshletMesh" , "Shader" , "ShaderStorageBuffer" , "DynamicScene" , "Scene" , "ColorMaterial" , "TextureAtlas" , "Wireframe2dMaterial" , "TilemapChunkMaterial" , "Font" , "FontAtlasSet"] ; # [doc = r" Register asset types at runtime using TypeRegistry"] # [doc = r" This looks up each discovered type name in the registry and registers"] # [doc = r" handlers for valid Asset types (handle setters, asset adders, etc.)"] pub fn register_asset_types_from_registry (asset_registry : & bevy_lua_ecs :: AssetRegistry , type_registry : & bevy :: ecs :: reflect :: AppTypeRegistry ,) { bevy_lua_ecs :: register_asset_types_runtime (asset_registry , type_registry , DISCOVERED_ASSET_TYPES ,) ; } # [doc = r" Auto-discovered Handle<T> newtype wrappers"] # [doc = r" Format: (newtype_name, inner_asset_name) - runtime will resolve via TypeRegistry"] # [doc = r#" Examples: ("ImageRenderTarget", "Image"), ("Mesh3d", "Mesh")"#] pub const DISCOVERED_NEWTYPE_WRAPPERS : & [(& str , & str)] = & [("LoadedFolder" , "UntypedHandle") , ("Skybox" , "Image") , ("TiledMap" , "TiledMapAsset") , ("TiledWorld" , "TiledWorldAsset") , ("TiledMapHandle" , "TiledMap") , ("TiledWorldHandle" , "TiledWorld") , ("SpotLightTexture" , "Image") , ("Mesh2d" , "Mesh") , ("Mesh3d" , "Mesh") , ("MeshletMesh3d" , "MeshletMesh") , ("Bluenoise" , "Image") , ("SimplifiedMesh" , "Mesh") , ("ManualTextureViews" , "ManualTextureViewHandle , ManualTextureView") , ("SceneRoot" , "Scene") , ("DynamicSceneRoot" , "DynamicScene") , ("Mesh2dHandle" , "Mesh") , ("WinitActionHandlers" , "Entity , WinitActionHandler")] ; # [doc = r" Register newtype wrappers at runtime using TypeRegistry discovery"] # [doc = r" Enables wrapping Handle<T> in newtypes like ImageRenderTarget"] pub fn register_auto_newtype_wrappers (newtype_wrappers : & std :: sync :: Arc < std :: sync :: Mutex < std :: collections :: HashMap < String , bevy_lua_ecs :: NewtypeWrapperCreator >> > ,) { bevy :: log :: info ! ("[NEWTYPE_WRAPPERS] Discovered {} newtype wrappers for runtime lookup" , DISCOVERED_NEWTYPE_WRAPPERS . len ()) ; for (newtype_name , inner_name) in DISCOVERED_NEWTYPE_WRAPPERS { bevy :: log :: debug ! ("[NEWTYPE_WRAPPERS]   - {} wraps Handle<{}>" , newtype_name , inner_name) ; } } # [doc = r" Dispatch a Lua observer callback for an entity"] fn dispatch_lua_observer (lua_ctx : & bevy_lua_ecs :: LuaScriptContext , observer_registry : & bevy_lua_ecs :: LuaObserverRegistry , update_queue : & bevy_lua_ecs :: ComponentUpdateQueue , entity : bevy :: prelude :: Entity , event_type : & str , position : Option < bevy :: math :: Vec2 > ,) { let callbacks = observer_registry . callbacks () . lock () . unwrap () ; if let Some (observers) = callbacks . get (& entity) { for (ev_type , callback_key) in observers { if ev_type == event_type { if let Ok (callback) = lua_ctx . lua . registry_value :: < mlua :: Function > (callback_key) { let entity_snapshot = bevy_lua_ecs :: LuaEntitySnapshot { entity , component_data : std :: collections :: HashMap :: new () , lua_components : std :: collections :: HashMap :: new () , update_queue : update_queue . clone () , } ; let event_table = lua_ctx . lua . create_table () . unwrap () ; if let Some (pos) = position { let _ = event_table . set ("x" , pos . x) ; let _ = event_table . set ("y" , pos . y) ; } if let Err (e) = callback . call :: < () > ((entity_snapshot , event_table)) { bevy :: log :: error ! ("[LUA_OBSERVER] Error calling {} callback: {}" , event_type , e) ; } } } } } } fn on_pointer_cancel_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: Cancel >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<Cancel>" , None) ; } fn on_pointer_over_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: Over >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<Over>" , None) ; } fn on_pointer_out_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: Out >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<Out>" , None) ; } fn on_pointer_down_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: Press >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<Down>" , None) ; } fn on_pointer_up_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: Release >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<Up>" , None) ; } fn on_pointer_click_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: Click >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<Click>" , None) ; } fn on_pointer_move_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: Move >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { let pos = event . event () . pointer_location . position ; dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<Move>" , Some (pos)) ; } fn on_pointer_dragstart_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: DragStart >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { let pos = event . event () . pointer_location . position ; dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<DragStart>" , Some (pos)) ; } fn on_pointer_drag_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: Drag >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { let pos = event . event () . pointer_location . position ; dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<Drag>" , Some (pos)) ; } fn on_pointer_dragend_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: DragEnd >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { let pos = event . event () . pointer_location . position ; dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<DragEnd>" , Some (pos)) ; } fn on_pointer_dragenter_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: DragEnter >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { let pos = event . event () . pointer_location . position ; dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<DragEnter>" , Some (pos)) ; } fn on_pointer_dragover_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: DragOver >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { let pos = event . event () . pointer_location . position ; dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<DragOver>" , Some (pos)) ; } fn on_pointer_dragleave_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: DragLeave >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { let pos = event . event () . pointer_location . position ; dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<DragLeave>" , Some (pos)) ; } fn on_pointer_dragdrop_lua (event : bevy :: prelude :: On < bevy :: prelude :: Pointer < bevy :: prelude :: DragDrop >> , lua_ctx : bevy :: prelude :: Res < bevy_lua_ecs :: LuaScriptContext > , observer_registry : bevy :: prelude :: Res < bevy_lua_ecs :: LuaObserverRegistry > , update_queue : bevy :: prelude :: Res < bevy_lua_ecs :: ComponentUpdateQueue > ,) { let pos = event . event () . pointer_location . position ; dispatch_lua_observer (& lua_ctx , & observer_registry , & update_queue , event . event () . entity , "Pointer<DragDrop>" , Some (pos)) ; } # [doc = r" Attach a Lua observer to an entity by event type name"] # [doc = r" This function is generated with match arms for all discovered observable events"] pub fn attach_observer_by_name (commands : & mut bevy :: prelude :: Commands , entity : bevy :: prelude :: Entity , event_type : & str ,) { match event_type { "Pointer<Cancel>" => { commands . entity (entity) . observe (on_pointer_cancel_lua) ; } "Pointer<Over>" => { commands . entity (entity) . observe (on_pointer_over_lua) ; } "Pointer<Out>" => { commands . entity (entity) . observe (on_pointer_out_lua) ; } "Pointer<Down>" => { commands . entity (entity) . observe (on_pointer_down_lua) ; } "Pointer<Up>" => { commands . entity (entity) . observe (on_pointer_up_lua) ; } "Pointer<Click>" => { commands . entity (entity) . observe (on_pointer_click_lua) ; } "Pointer<Move>" => { commands . entity (entity) . observe (on_pointer_move_lua) ; } "Pointer<DragStart>" => { commands . entity (entity) . observe (on_pointer_dragstart_lua) ; } "Pointer<Drag>" => { commands . entity (entity) . observe (on_pointer_drag_lua) ; } "Pointer<DragEnd>" => { commands . entity (entity) . observe (on_pointer_dragend_lua) ; } "Pointer<DragEnter>" => { commands . entity (entity) . observe (on_pointer_dragenter_lua) ; } "Pointer<DragOver>" => { commands . entity (entity) . observe (on_pointer_dragover_lua) ; } "Pointer<DragLeave>" => { commands . entity (entity) . observe (on_pointer_dragleave_lua) ; } "Pointer<DragDrop>" => { commands . entity (entity) . observe (on_pointer_dragdrop_lua) ; } _ => bevy :: log :: warn ! ("[LUA_OBSERVER] Unknown observer type: {}" , event_type) , } } # [doc = r" Plugin that wraps LuaSpawnPlugin and automatically registers all auto-generated bindings."] # [doc = r" Use this instead of LuaSpawnPlugin directly to get automatic bitflags, component bindings,"] # [doc = r" handle setters, and asset adders registration."] pub struct LuaBindingsPlugin ; impl bevy :: prelude :: Plugin for LuaBindingsPlugin { fn build (& self , app : & mut bevy :: prelude :: App) { app . add_plugins (bevy_lua_ecs :: LuaSpawnPlugin) ; bevy_lua_ecs :: set_observer_attacher (attach_observer_by_name) ; app . init_resource :: < bevy_lua_ecs :: BitflagsRegistry > () ; app . add_systems (bevy :: prelude :: Startup , setup_bitflags) ; app . add_systems (bevy :: prelude :: PostStartup , register_asset_constructors) ; } } # [doc = r" System to register auto-generated bitflags types"] fn setup_bitflags (registry : bevy :: prelude :: Res < bevy_lua_ecs :: BitflagsRegistry >) { register_auto_bitflags (& registry) ; bevy :: log :: info ! ("Auto-generated bitflags registered") ; } # [doc = r" System to register auto-generated asset constructors, handle setters, and component bindings"] fn register_asset_constructors (asset_registry : bevy :: prelude :: Res < bevy_lua_ecs :: AssetRegistry > , type_registry : bevy :: prelude :: Res < bevy :: ecs :: reflect :: AppTypeRegistry > , mut component_registry : bevy :: prelude :: ResMut < bevy_lua_ecs :: ComponentRegistry > ,) { register_entity_wrappers_from_registry (& mut component_registry , & type_registry) ; register_asset_types_from_registry (& asset_registry , & type_registry) ; register_auto_newtype_wrappers (& asset_registry . newtype_wrappers ,) ; register_asset_cloners (& asset_registry) ; register_asset_constructor_bindings (& asset_registry) ; bevy :: log :: info ! ("Auto-generated asset constructors, component bindings, and newtype wrappers registered") ; } # [doc = r" Register asset cloners for types that implement Clone"] # [doc = r" This is auto-generated based on compile-time detection of Clone derives/impls"] fn register_asset_cloners (asset_registry : & bevy_lua_ecs :: AssetRegistry) { let mut cloners = asset_registry . asset_cloners_by_typeid . lock () . unwrap () ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: animation :: AnimationClip > (& mut cloners) ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: audio :: AudioSource > (& mut cloners) ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: gizmos :: GizmoAsset > (& mut cloners) ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: gltf :: GltfNode > (& mut cloners) ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: gltf :: GltfMesh > (& mut cloners) ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: gltf :: GltfPrimitive > (& mut cloners) ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: gltf :: GltfSkin > (& mut cloners) ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: prelude :: Image > (& mut cloners) ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: prelude :: Mesh > (& mut cloners) ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: prelude :: StandardMaterial > (& mut cloners) ; bevy_lua_ecs :: register_cloner_if_clone :: < bevy :: text :: Font > (& mut cloners) ; bevy :: log :: info ! ("[ASSET_CLONER] Registered {} asset cloners (types with Clone impl)" , cloners . len ()) ; } # [doc = r" Register asset constructors for opaque types that need explicit constructors"] # [doc = r" This is auto-generated based on discovered constructor methods"] fn register_asset_constructor_bindings (asset_registry : & bevy_lua_ecs :: AssetRegistry) { asset_registry . register_asset_constructor ("bevy_image::image::Image" , | table | { let width : u32 = table . get ("width") . unwrap_or (0) ; let height : u32 = table . get ("height") . unwrap_or (0) ; let format = { use bevy :: render :: render_resource :: TextureFormat ; let format_str : String = table . get ("format") . unwrap_or_else (| _ | "Bgra8UnormSrgb" . to_string ()) ; match format_str . as_str () { "Rgba8UnormSrgb" => TextureFormat :: Rgba8UnormSrgb , "Bgra8UnormSrgb" => TextureFormat :: Bgra8UnormSrgb , "Rgba8Unorm" => TextureFormat :: Rgba8Unorm , "Bgra8Unorm" => TextureFormat :: Bgra8Unorm , "Rgba16Float" => TextureFormat :: Rgba16Float , "Rgba32Float" => TextureFormat :: Rgba32Float , "R8Unorm" => TextureFormat :: R8Unorm , "Rg8Unorm" => TextureFormat :: Rg8Unorm , _ => TextureFormat :: Bgra8UnormSrgb , } } ; bevy :: log :: debug ! ("[AUTO_CONSTRUCTOR] Calling {}::{}" , stringify ! (bevy :: prelude :: Image) , stringify ! (new_target_texture)) ; Ok (Box :: new (bevy :: prelude :: Image :: new_target_texture (width , height , format)) as Box < dyn bevy :: reflect :: Reflect >) }) ; bevy :: log :: info ! ("[ASSET_CONSTRUCTOR] Registered auto-discovered asset constructors for opaque types") ; }