use bevy::prelude::*;
use bevy::asset::{ReflectAsset, UntypedAssetId, RenderAssetUsages};
use bevy::render::render_resource::TextureUsages;
use bevy::reflect::{PartialReflect, Reflect, TypeRegistration};
use mlua::prelude::*;
use mlua::RegistryKey;
use std::collections::HashMap;
use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::{Arc, Mutex};

/// Type-erased function that sets a Handle<T> field from an UntypedHandle
pub type HandleSetter = Box<dyn Fn(&mut dyn PartialReflect, UntypedHandle) -> bool + Send + Sync>;

/// Type-erased asset adder function (adds asset to world and returns UntypedHandle)
/// Generated by build.rs for each asset type specified in [package.metadata.lua_assets.types]
pub type AssetAdder = Box<dyn Fn(&mut World, &dyn Reflect) -> Option<UntypedHandle> + Send + Sync>;

/// Type-erased asset cloner function that uses &dyn Any for proper downcasting
/// This preserves non-Reflect data (like Mesh vertex attributes) by cloning the actual object
/// rather than reconstructing from reflection
pub type AssetCloner = Box<dyn Fn(&mut World, &dyn std::any::Any) -> Option<UntypedHandle> + Send + Sync>;

/// Type-erased asset constructor function (from Lua table to Box<dyn Reflect>)
/// Generated by build.rs for each asset type with constructor specs
pub type AssetConstructor = Box<dyn Fn(&mlua::Table) -> LuaResult<Box<dyn Reflect>> + Send + Sync>;

/// Type-erased handle creator function (creates typed Handle<T> box from UntypedHandle)
/// Used for dynamically creating correctly typed handles for newtypes like ImageRenderTarget
pub type HandleCreator = Box<dyn Fn(UntypedHandle) -> Box<dyn PartialReflect> + Send + Sync>;

/// Type-erased newtype wrapper constructor (wraps typed Handle<T> in newtype like ImageRenderTarget)
/// Takes a typed handle box and returns the wrapped newtype box
/// Key should be the newtype type path (e.g., "bevy_camera::camera::ImageRenderTarget")
pub type NewtypeWrapperCreator = Box<dyn Fn(Box<dyn PartialReflect>) -> Box<dyn PartialReflect> + Send + Sync>;

/// Parse an enum value from a string variant name using reflection
/// This is used by auto-generated constructor code to parse enum parameters from Lua strings
/// 
/// # Example
/// ```rust,ignore
/// let format = parse_enum_from_string::<TextureFormat>("Bgra8UnormSrgb")?;
/// ```
pub fn parse_enum_from_string<E: bevy::reflect::GetTypeRegistration + bevy::reflect::FromReflect + Default + Clone>(
    variant_name: &str
) -> Option<E> {
    use bevy::reflect::{DynamicEnum, DynamicVariant, TypeInfo};
    
    // Get type info for the enum
    let type_registration = E::get_type_registration();
    let type_info = type_registration.type_info();
    
    // Must be an enum
    let TypeInfo::Enum(enum_info) = type_info else {
        return None;
    };
    
    // Find the variant
    let variant = enum_info.variant(variant_name)?;
    
    // Create dynamic enum with this variant
    let dynamic_enum = DynamicEnum::new(variant_name, DynamicVariant::Unit);
    
    // Convert via FromReflect
    E::from_reflect(&dynamic_enum)
}

/// Type data for direct asset addition that bypasses FromReflect
/// 
/// This is registered with the TypeRegistry alongside ReflectAsset for each asset type.
/// It captures the concrete type at registration time and uses `as_any().downcast_ref::<T>().clone()`
/// to add assets directly to `Assets<T>`, preserving all data including non-Reflect fields
/// (like Mesh vertex attributes).
/// 
/// # Usage
/// ```rust,ignore
/// // Registration (done by generated code)
/// app.register_type_data::<Mesh, ReflectDirectAssetAdd>();
/// 
/// // Usage at runtime
/// if let Some(direct_add) = registration.data::<ReflectDirectAssetAdd>() {
///     if let Some(handle) = direct_add.add(asset.as_any(), world) {
///         // Asset added with all data preserved!
///     }
/// }
/// ```
#[derive(Clone)]
pub struct ReflectDirectAssetAdd {
    add_fn: fn(&dyn std::any::Any, &mut World) -> Option<UntypedHandle>,
}

impl ReflectDirectAssetAdd {
    /// Create type data for a specific asset type
    /// Called at compile time (in generated code) to capture the concrete type
    pub fn from_type<T: Asset + Clone + 'static>() -> Self {
        Self {
            add_fn: |asset: &dyn std::any::Any, world: &mut World| -> Option<UntypedHandle> {
                // Downcast using Any - preserves ALL data including non-Reflect fields!
                let concrete = asset.downcast_ref::<T>()?;
                let mut assets = world.resource_mut::<Assets<T>>();
                Some(assets.add(concrete.clone()).untyped())
            }
        }
    }
    
    /// Add asset to world using direct cloning (bypasses FromReflect)
    /// Returns None if downcast fails (asset is not the expected type)
    pub fn add(&self, asset: &dyn std::any::Any, world: &mut World) -> Option<UntypedHandle> {
        (self.add_fn)(asset, world)
    }
}

// Implement TypePath for ReflectDirectAssetAdd so it can be registered as type data
impl bevy::reflect::TypePath for ReflectDirectAssetAdd {
    fn type_path() -> &'static str {
        "bevy_lua_ecs::asset_loading::ReflectDirectAssetAdd"
    }
    
    fn short_type_path() -> &'static str {
        "ReflectDirectAssetAdd"
    }
}

// Implement FromType to enable register_type_data calls
// This is required by Bevy's TypeRegistry::register_type_data
impl<T: Asset + Clone + 'static> bevy::reflect::FromType<T> for ReflectDirectAssetAdd {
    fn from_type() -> Self {
        ReflectDirectAssetAdd::from_type::<T>()
    }
}

/// Helper function for registering asset cloners
/// 
/// This function is called by generated code for each discovered asset type.
/// The trait bounds (Asset + Clone) mean this function only compiles for valid types.
/// Types that don't implement these traits will cause compile errors in the generated code,
/// which we handle by wrapping calls in a separate function that uses the autoref trick.
/// 
/// The generated code calls `register_cloner_if_clone::<T>()` for each discovered type.
pub fn register_cloner_if_clone<T: Asset + Clone + 'static>(
    cloners: &mut HashMap<std::any::TypeId, AssetCloner>
) {
    let cloner: AssetCloner = Box::new(|world: &mut World, asset: &dyn std::any::Any| -> Option<UntypedHandle> {
        // Downcast to concrete type and clone - preserves ALL data
        let concrete = asset.downcast_ref::<T>()?;
        let mut assets = world.resource_mut::<Assets<T>>();
        Some(assets.add(concrete.clone()).untyped())
    });
    cloners.insert(std::any::TypeId::of::<T>(), cloner);
}

/// Pending asset to be created via reflection
#[derive(Clone)]
pub struct PendingAsset {
    pub type_name: String,
    pub data: Arc<RegistryKey>,
}

/// Resource that manages loaded and created assets, providing asset IDs to Lua
#[derive(Resource, Clone)]
pub struct AssetRegistry {
    /// Maps asset IDs to Image handles (for load_asset)
    image_handles: Arc<Mutex<HashMap<u32, Handle<Image>>>>,
    
    /// Maps asset IDs to typed asset handles (for created assets - stored as UntypedHandle)
    typed_handles: Arc<Mutex<HashMap<u32, UntypedHandle>>>,
    
    /// Maps asset IDs to (type_name, UntypedAssetId) for created assets
    asset_handles: Arc<Mutex<HashMap<u32, (String, UntypedAssetId)>>>,
    
    /// Pending assets to be created
    pending_assets: Arc<Mutex<HashMap<u32, PendingAsset>>>,
    
    /// Counter for generating unique asset IDs
    next_id: Arc<AtomicU32>,
    
    /// Type-erased handle setters for each asset type (fully generic!)
    /// Key: type path string (for backward compatibility with generated code)
    pub handle_setters: Arc<Mutex<HashMap<String, HandleSetter>>>,
    
    /// TypeId-keyed handle setters (for runtime-discovered types)
    /// Key: TypeId of Handle<T>
    pub handle_setters_by_typeid: Arc<Mutex<HashMap<std::any::TypeId, HandleSetter>>>,
    
    /// Type-erased asset adders for each asset type (fully generic!)
    /// Key: type path (e.g., "bevy_image::image::Image")
    pub asset_adders: Arc<Mutex<HashMap<String, AssetAdder>>>,
    
    /// TypeId-keyed asset adders (for runtime-discovered types)
    /// Key: TypeId of asset type T
    pub asset_adders_by_typeid: Arc<Mutex<HashMap<std::any::TypeId, AssetAdder>>>,
    
    /// Type-erased asset constructors registered by generated code
    /// Key: type path (e.g., "bevy_image::image::Image")
    asset_constructors: Arc<Mutex<HashMap<String, AssetConstructor>>>,
    
    /// Type-erased handle creators for dynamically creating typed Handle<T> boxes
    /// Key: Handle type path (e.g., "bevy_asset::handle::Handle<bevy_image::image::Image>")
    pub handle_creators: Arc<Mutex<HashMap<String, HandleCreator>>>,
    
    /// TypeId-keyed handle creators (for runtime-discovered types)
    /// Key: TypeId of Handle<T>
    pub handle_creators_by_typeid: Arc<Mutex<HashMap<std::any::TypeId, HandleCreator>>>,
    
    /// Type-erased newtype wrapper constructors for wrapping typed handles in newtypes
    /// Key: Newtype type path (e.g., "bevy_camera::camera::ImageRenderTarget")
    pub newtype_wrappers: Arc<Mutex<HashMap<String, NewtypeWrapperCreator>>>,
    
    /// Cache for dynamically discovered newtype wrappers (via reflection)
    /// Stores type paths that were successfully constructed via ReflectFromReflect
    /// to avoid repeated TypeRegistry lookups
    discovered_newtype_cache: Arc<Mutex<std::collections::HashSet<String>>>,
    
    /// Stores which asset type names have been successfully registered at runtime
    /// Used to prevent duplicate registration and for debug logging
    pub registered_asset_types: Arc<Mutex<std::collections::HashSet<String>>>,
    
    /// TypeId-keyed asset cloners that use &dyn Any for proper downcasting
    /// These preserve non-Reflect data (like Mesh vertex attributes) by cloning the actual object
    pub asset_cloners_by_typeid: Arc<Mutex<HashMap<std::any::TypeId, AssetCloner>>>,
}

impl Default for AssetRegistry {
    fn default() -> Self {
        Self {
            image_handles: Default::default(),
            typed_handles: Default::default(),
            asset_handles: Default::default(),
            pending_assets: Default::default(),
            next_id: Default::default(),
            handle_setters: Default::default(),
            handle_setters_by_typeid: Default::default(),
            asset_adders: Default::default(),
            asset_adders_by_typeid: Default::default(),
            asset_constructors: Default::default(),
            handle_creators: Default::default(),
            handle_creators_by_typeid: Default::default(),
            newtype_wrappers: Default::default(),
            discovered_newtype_cache: Default::default(),
            registered_asset_types: Default::default(),
            asset_cloners_by_typeid: Default::default(),
        }
    }
}

/// Macro to register handle setters for asset types
/// Usage: register_handle_setters!(registry, Image, Mesh, StandardMaterial, ...)
/// This allows users to specify which asset types they need in their game
/// Registers both Handle<T> and Option<Handle<T>> setters!
#[macro_export]
macro_rules! register_handle_setters {
    ($registry:expr, $type_registry:expr, $($asset_type:ty),* $(,)?) => {
        {
            let registry_guard = $type_registry.read();
            $(
                // For each asset type, create setters for both Handle<T> and Option<Handle<T>>
                let type_path = std::any::type_name::<$asset_type>();
                if let Some(registration) = registry_guard.get_with_type_path(type_path) {
                    if registration.data::<bevy::asset::ReflectAsset>().is_some() {
                        // 1. Register setter for Handle<T>
                        let handle_type_path = format!("bevy_asset::handle::Handle<{}>", type_path);
                        let setter: Box<dyn Fn(&mut dyn bevy::reflect::PartialReflect, bevy::asset::UntypedHandle) -> bool + Send + Sync> = 
                            Box::new(|field, handle| {
                                if let Some(h) = field.try_downcast_mut::<bevy::asset::Handle<$asset_type>>() {
                                    *h = handle.typed();
                                    true
                                } else {
                                    false
                                }
                            });
                        $registry.insert(handle_type_path.clone(), setter);
                        
                        // 2. Register setter for Option<Handle<T>> (critical for StandardMaterial textures!)
                        let option_type_path = format!("core::option::Option<bevy_asset::handle::Handle<{}>>", type_path);
                        let option_setter: Box<dyn Fn(&mut dyn bevy::reflect::PartialReflect, bevy::asset::UntypedHandle) -> bool + Send + Sync> = 
                            Box::new(|field, handle| {
                                if let Some(opt) = field.try_downcast_mut::<Option<bevy::asset::Handle<$asset_type>>>() {
                                    *opt = Some(handle.typed());
                                    true
                                } else {
                                    false
                                }
                            });
                        $registry.insert(option_type_path, option_setter);
                    }
                }
            )*
        }
    };
}

/// Macro to register handle creators for asset types
/// Usage: register_handle_creators!(registry, type_registry, Image, Mesh, StandardMaterial, ...)
/// Creates closures that convert UntypedHandle to boxed typed Handle<T>
#[macro_export]
macro_rules! register_handle_creators {
    ($registry:expr, $type_registry:expr, $($asset_type:ty),* $(,)?) => {
        {
            let registry_guard = $type_registry.read();
            $(
                let type_path = std::any::type_name::<$asset_type>();
                if let Some(registration) = registry_guard.get_with_type_path(type_path) {
                    if registration.data::<bevy::asset::ReflectAsset>().is_some() {
                        // Register creator for Handle<T>
                        let handle_type_path = format!("bevy_asset::handle::Handle<{}>", type_path);
                        let creator: Box<dyn Fn(bevy::asset::UntypedHandle) -> Box<dyn bevy::reflect::PartialReflect> + Send + Sync> = 
                            Box::new(|untyped| {
                                Box::new(untyped.typed::<$asset_type>()) as Box<dyn bevy::reflect::PartialReflect>
                            });
                        $registry.insert(handle_type_path.clone(), creator);
                    }
                }
            )*
        }
    };
}

/// Macro to register newtype wrapper constructors
/// Usage: register_newtype_wrappers!(registry.newtype_wrappers, 
///     (ImageRenderTarget, Handle<Image>),
///     ...
/// );
/// Creates closures that take a typed Handle<T> box and wrap it in newtype
#[macro_export]
macro_rules! register_newtype_wrappers {
    ($wrappers:expr, $(($newtype:ty, $handle_type:ty)),* $(,)?) => {
        {
            $(
                // Get the newtype's type path for the registry key
                let newtype_path = std::any::type_name::<$newtype>().to_string();
                
                // Create wrapper closure
                let wrapper: Box<dyn Fn(Box<dyn bevy::reflect::PartialReflect>) -> Box<dyn bevy::reflect::PartialReflect> + Send + Sync> = 
                    Box::new(|handle_box| {
                        // Try to downcast to the expected handle type
                        if let Some(handle) = handle_box.try_downcast_ref::<$handle_type>() {
                            Box::new(<$newtype>::from(handle.clone())) as Box<dyn bevy::reflect::PartialReflect>
                        } else {
                            // Fallback: try type erasure approach
                            bevy::log::warn!("[NEWTYPE_WRAP] Failed to downcast to {}", std::any::type_name::<$handle_type>());
                            handle_box
                        }
                    });
                
                $wrappers.lock().unwrap().insert(newtype_path, wrapper);
            )*
        }
    };
}

/// Register asset types at runtime using TypeRegistry lookup
/// 
/// This function iterates through discovered asset type names (strings),
/// looks them up in the TypeRegistry, and registers handlers keyed by TypeId.
/// Types not found in the registry are silently skipped with a debug log.
/// 
/// # Arguments
/// * `asset_registry` - The AssetRegistry to populate with handlers
/// * `type_registry` - Bevy's AppTypeRegistry to look up types
/// * `discovered_names` - Array of asset type short names (e.g., ["Image", "Mesh", "StandardMaterial"])
pub fn register_asset_types_runtime(
    asset_registry: &AssetRegistry,
    type_registry: &bevy::ecs::reflect::AppTypeRegistry,
    discovered_names: &[&str],
) {
    let registry = type_registry.read();
    let mut registered = asset_registry.registered_asset_types.lock().unwrap();
    
    // Log all discovered names for debugging
    trace!("[RUNTIME_ASSET] Attempting to register {} discovered asset type names", discovered_names.len());
    
    for type_name in discovered_names {
        // Skip if already registered
        if registered.contains(*type_name) {
            continue;
        }
        
        // 1. Find type by short name in registry
        let Some(type_registration) = registry.get_with_short_type_path(type_name) else {
            trace!("[RUNTIME_ASSET] Type not found in registry: {}", type_name);
            continue;
        };
        
        // 2. Must be an Asset type with ReflectAsset data
        let Some(reflect_asset) = type_registration.data::<ReflectAsset>() else {
            trace!("[RUNTIME_ASSET] {} found but is not an Asset type (no ReflectAsset data)", type_name);
            continue;
        };
        
        // 3. Get TypeIds
        let asset_type_id = type_registration.type_id();
        let handle_type_id = reflect_asset.handle_type_id();
        let type_path = type_registration.type_info().type_path().to_string();
        
        // 4. Register asset adder by TypeId
        // Uses ReflectAsset::add to add assets via reflection
        {
            let reflect_asset_for_typeid = reflect_asset.clone();
            let reflect_asset_for_string = reflect_asset.clone();
            let type_path_clone_1 = type_path.clone();
            let type_path_clone_2 = type_path.clone();
            
            let adder: AssetAdder = Box::new(move |world: &mut World, asset: &dyn Reflect| -> Option<UntypedHandle> {
                // ReflectAsset::add takes &dyn Reflect and adds to Assets<T>
                let handle = reflect_asset_for_typeid.add(world, asset);
                debug!("[RUNTIME_ASSET] Added asset of type {} -> handle {:?}", type_path_clone_1, handle);
                Some(handle)
            });
            
            asset_registry.asset_adders_by_typeid.lock().unwrap().insert(asset_type_id, adder);
            
            // Also register by type path string for backward compatibility
            let adder_string: AssetAdder = Box::new(move |world: &mut World, asset: &dyn Reflect| -> Option<UntypedHandle> {
                let handle = reflect_asset_for_string.add(world, asset);
                debug!("[RUNTIME_ASSET] Added asset of type {} -> handle {:?}", type_path_clone_2, handle);
                Some(handle)
            });
            asset_registry.asset_adders.lock().unwrap().insert(type_path.clone(), adder_string);
        }
        
        // 5. Register handle creator by TypeId
        // Creates a typed Handle<T> box from an UntypedHandle
        // Note: We can't do handle.typed::<T>() without compile-time type, 
        // but we can use the UntypedHandle directly and let reflection handle it
        {
            let creator: HandleCreator = Box::new(move |untyped: UntypedHandle| -> Box<dyn PartialReflect> {
                // Return the UntypedHandle boxed - it implements Reflect
                Box::new(untyped) as Box<dyn PartialReflect>
            });
            
            asset_registry.handle_creators_by_typeid.lock().unwrap().insert(handle_type_id, creator);
        }
        
        // 6. Mark as registered
        registered.insert(type_name.to_string());
        debug!("[RUNTIME_ASSET] âœ“ Registered asset type: {} (TypeId: {:?})", type_name, asset_type_id);
    }
    
    // Log summary with type names for debugging
    let registered_names: Vec<_> = registered.iter().cloned().collect();
    debug!("[RUNTIME_ASSET] Registered {} asset types at runtime: {:?}", registered.len(), registered_names);
}

impl AssetRegistry {
    /// Create AssetRegistry with empty handle setters (user must register types they need)
    pub fn new() -> Self {
        Self {
            image_handles: Default::default(),
            typed_handles: Default::default(),
            asset_handles: Default::default(),
            pending_assets: Default::default(),
            next_id: Default::default(),
            handle_setters: Arc::new(Mutex::new(HashMap::new())),
            handle_setters_by_typeid: Default::default(),
            asset_adders: Default::default(),
            asset_adders_by_typeid: Default::default(),
            asset_constructors: Default::default(),
            handle_creators: Default::default(),
            handle_creators_by_typeid: Default::default(),
            newtype_wrappers: Default::default(),
            discovered_newtype_cache: Default::default(),
            registered_asset_types: Default::default(),
            asset_cloners_by_typeid: Default::default(),
        }
    }
    
    /// Create AssetRegistry and populate with common Bevy asset types
    /// This is a convenience method - for full Zero Rust, use new() + register_asset_types!
    pub fn from_type_registry(type_registry: &AppTypeRegistry) -> Self {
        use bevy::prelude::*;
        
        let mut handle_setters: HashMap<String, HandleSetter> = HashMap::new();
        
        // Register common Bevy asset types using the macro
        // Users can customize this list in their own code
        register_handle_setters!(
            handle_setters,
            type_registry,
            Image,
            Mesh,
            StandardMaterial,
            Scene,
            AnimationClip,
            AudioSource,
            Font,
        );
        
        debug!("âœ“ Registered {} handle setters for asset types", handle_setters.len());
        debug!("ðŸ“‹ Registered asset type paths:");
        for type_path in handle_setters.keys() {
            debug!("  - {}", type_path);
        }
        
        Self {
            image_handles: Default::default(),
            typed_handles: Default::default(),
            asset_handles: Default::default(),
            pending_assets: Default::default(),
            next_id: Default::default(),
            handle_setters: Arc::new(Mutex::new(handle_setters)),
            handle_setters_by_typeid: Default::default(),
            asset_adders: Default::default(),
            asset_adders_by_typeid: Default::default(),
            asset_constructors: Default::default(),
            handle_creators: Default::default(),
            handle_creators_by_typeid: Default::default(),
            newtype_wrappers: Default::default(),
            discovered_newtype_cache: Default::default(),
            registered_asset_types: Default::default(),
            asset_cloners_by_typeid: Default::default(),
        }
    }
    
    /// Auto-discover and register handle creators for all asset types in TypeRegistry
    /// This eliminates the need for manual configuration in Cargo.toml
    /// 
    /// Discovery method: Iterates TypeRegistry looking for types with ReflectAsset type data,
    /// which indicates they are registered asset types (Image, Mesh, StandardMaterial, etc.)
    pub fn discover_and_register_handle_creators(&self, type_registry: &AppTypeRegistry) {
        use bevy::reflect::TypeInfo;
        
        let registry = type_registry.read();
        let mut handle_creators = self.handle_creators.lock().unwrap();
        let mut handle_setters = self.handle_setters.lock().unwrap();
        
        let mut discovered_count = 0;
        
        // Find all types with ReflectAsset - these are registered asset types
        for registration in registry.iter() {
            if registration.data::<ReflectAsset>().is_some() {
                let type_path = registration.type_info().type_path();
                let handle_type_path = format!("bevy_asset::handle::Handle<{}>", type_path);
                
                // Skip if already registered (from Cargo.toml config)
                if handle_creators.contains_key(&handle_type_path) {
                    continue;
                }
                
                // Create a handle creator closure using reflection
                // We store the type_path to use in the closure
                let creator_type_path = type_path.to_string();
                let creator: HandleCreator = Box::new(move |untyped: UntypedHandle| {
                    // Create a DynamicStruct representing the Handle
                    // This is a workaround since we can't call untyped.typed::<T>() generically
                    // The key insight: we store the UntypedHandle in a wrapper that reflects as Handle<T>
                    debug!("[HANDLE_DISCOVER] Creating handle for asset type: {}", creator_type_path);
                    
                    // For runtime discovery, we can't create typed handles without knowing T at compile time
                    // Instead, we return the UntypedHandle wrapped in a box that claims to be Handle<T>
                    // The consumer (try_wrap_in_newtype_with_reflection) will use this
                    Box::new(untyped) as Box<dyn PartialReflect>
                });
                
                handle_creators.insert(handle_type_path.clone(), creator);
                discovered_count += 1;
                debug!("[ASSET_DISCOVER] âœ“ Discovered asset type: {} -> {}", type_path, handle_type_path);
                
                // Also register handle setters for discovered types
                // Note: Handle setters require compile-time type knowledge for downcast_mut
                // So we can only log a warning here - they need macro registration
                if !handle_setters.contains_key(&handle_type_path) {
                    debug!("[ASSET_DISCOVER] âš  Handle setter not registered for {} (requires compile-time registration)", handle_type_path);
                }
            }
        }
        
        if discovered_count > 0 {
            debug!("[ASSET_DISCOVER] Auto-discovered {} asset types for handle creators", discovered_count);
        }
    }
    
    /// Auto-discover entity wrapper components (newtypes around Entity)
    /// These are components like UiTargetCamera that wrap a single Entity field
    pub fn discover_entity_components(type_registry: &AppTypeRegistry) -> Vec<(String, String)> {
        use bevy::reflect::{TypeInfo, ReflectRef};
        use bevy::ecs::reflect::ReflectComponent;
        
        let registry = type_registry.read();
        let mut entity_components = Vec::new();
        
        for registration in registry.iter() {
            // Only look at components
            if registration.data::<ReflectComponent>().is_none() {
                continue;
            }
            
            let type_info = registration.type_info();
            let type_path = type_info.type_path().to_string();
            let short_name = type_info.type_path_table().short_path().to_string();
            
            // Check if this is a newtype wrapper around Entity
            let is_entity_wrapper = match type_info {
                TypeInfo::TupleStruct(ts) if ts.field_len() == 1 => {
                    ts.field_at(0)
                        .map(|f| f.type_path().contains("Entity"))
                        .unwrap_or(false)
                }
                TypeInfo::Struct(s) if s.field_len() == 1 => {
                    s.field_at(0)
                        .map(|f| f.type_path().contains("Entity"))
                        .unwrap_or(false)
                }
                _ => false,
            };
            
            if is_entity_wrapper {
                debug!("[ENTITY_DISCOVER] âœ“ Found Entity wrapper component: {} ({})", short_name, type_path);
                entity_components.push((short_name, type_path));
            }
        }
        
        if !entity_components.is_empty() {
            debug!("[ENTITY_DISCOVER] Auto-discovered {} Entity wrapper components", entity_components.len());
        }
        
        entity_components
    }
    
    /// Try to set a handle field using the registered handle setters
    pub fn try_set_handle_field(
        &self,
        field: &mut dyn PartialReflect,
        field_type_path: &str,
        untyped_handle: UntypedHandle,
    ) -> bool {
        // Info log to trace field type path matching
        debug!("[HANDLE_SET] Looking for setter for field type: '{}'", field_type_path);
        
        let handle_setters = self.handle_setters.lock().unwrap();
        if let Some(setter) = handle_setters.get(field_type_path) {
            debug!("[HANDLE_SET] âœ“ Found setter for '{}'", field_type_path);
            let result = setter(field, untyped_handle);
            debug!("[HANDLE_SET]   Setter returned: {}", result);
            result
        } else {
            debug!("[HANDLE_SET] âœ— No setter found for '{}'. Registered paths:", field_type_path);
            for path in handle_setters.keys() {
                debug!("[HANDLE_SET]   - {}", path);
            }
            false
        }
    }
    
    /// Try to create a boxed typed Handle<T> from an UntypedHandle
    /// Used for dynamically creating correctly typed handles for newtypes
    /// The inner_type_path should be the full handle type path (e.g., "bevy_asset::handle::Handle<bevy_image::image::Image>")
    pub fn try_create_typed_handle_box(
        &self,
        inner_type_path: &str,
        untyped_handle: UntypedHandle,
    ) -> Option<Box<dyn PartialReflect>> {
        let handle_creators = self.handle_creators.lock().unwrap();
        debug!("[HANDLE_CREATE] Looking for creator for type: '{}'", inner_type_path);
        
        if let Some(creator) = handle_creators.get(inner_type_path) {
            debug!("[HANDLE_CREATE] âœ“ Found creator for '{}'", inner_type_path);
            Some(creator(untyped_handle))
        } else {
            debug!("[HANDLE_CREATE] âœ— No creator found for '{}'. Registered paths:", inner_type_path);
            for path in handle_creators.keys() {
                debug!("[HANDLE_CREATE]   - {}", path);
            }
            None
        }
    }
    
    /// Try to wrap a typed handle in a newtype wrapper (e.g., Handle<Image> -> ImageRenderTarget)
    /// Returns Some(wrapped) if a wrapper is registered for the newtype_type_path
    /// 
    /// This is the legacy version without reflection fallback - prefer try_wrap_in_newtype_with_reflection
    pub fn try_wrap_in_newtype(
        &self,
        newtype_type_path: &str,
        typed_handle: Box<dyn PartialReflect>,
    ) -> Option<Box<dyn PartialReflect>> {
        let wrappers = self.newtype_wrappers.lock().unwrap();
        debug!("[NEWTYPE_WRAP] Looking for wrapper for type: '{}'", newtype_type_path);
        
        if let Some(wrapper) = wrappers.get(newtype_type_path) {
            debug!("[NEWTYPE_WRAP] âœ“ Found wrapper for '{}'", newtype_type_path);
            Some(wrapper(typed_handle))
        } else {
            debug!("[NEWTYPE_WRAP] âœ— No wrapper found for '{}'. Registered paths:", newtype_type_path);
            for path in wrappers.keys() {
                debug!("[NEWTYPE_WRAP]   - {}", path);
            }
            None
        }
    }
    
    /// Try to wrap a typed handle in a newtype wrapper with reflection-based auto-discovery
    /// 
    /// This method first checks for registered wrappers (fast path), then falls back to
    /// dynamic construction using Bevy's ReflectFromReflect + DynamicTupleStruct.
    /// Successfully discovered newtypes are cached for subsequent calls.
    /// 
    /// # Arguments
    /// * `newtype_type_path` - The full type path of the newtype (e.g., "bevy_render::camera::ImageRenderTarget")
    /// * `typed_handle` - A boxed typed Handle<T> to wrap in the newtype
    /// * `type_registry` - Bevy's AppTypeRegistry for reflection-based construction
    pub fn try_wrap_in_newtype_with_reflection(
        &self,
        newtype_type_path: &str,
        typed_handle: Box<dyn PartialReflect>,
        type_registry: &AppTypeRegistry,
    ) -> Option<Box<dyn PartialReflect>> {
        use bevy::reflect::{DynamicTupleStruct, ReflectFromReflect};
        
        debug!("[NEWTYPE_WRAP_REFLECT] Looking for wrapper for type: '{}'", newtype_type_path);
        
        // Fast path: check registered wrappers first
        {
            let wrappers = self.newtype_wrappers.lock().unwrap();
            if let Some(wrapper) = wrappers.get(newtype_type_path) {
                debug!("[NEWTYPE_WRAP_REFLECT] âœ“ Found registered wrapper for '{}'", newtype_type_path);
                return Some(wrapper(typed_handle));
            }
        }
        
        // Check if this type was previously discovered and failed
        // (We don't cache failures to allow for types being registered later,
        //  but we do cache successes as a positive indicator)
        
        // Fallback: use reflection to construct the newtype dynamically
        let registry = type_registry.read();
        
        // Look up the newtype's registration
        let registration = registry.get_with_type_path(newtype_type_path).or_else(|| {
            // Try short path match (e.g., "ImageRenderTarget" instead of full path)
            let short_name = newtype_type_path.rsplit("::").next().unwrap_or(newtype_type_path);
            registry.get_with_short_type_path(short_name)
        });
        
        let Some(registration) = registration else {
            debug!("[NEWTYPE_WRAP_REFLECT] âœ— Type '{}' not found in TypeRegistry", newtype_type_path);
            return None;
        };
        
        // Get ReflectFromReflect trait data
        let Some(reflect_from_reflect) = registration.data::<ReflectFromReflect>() else {
            debug!("[NEWTYPE_WRAP_REFLECT] âœ— Type '{}' has no ReflectFromReflect registered", newtype_type_path);
            return None;
        };
        
        // Check if this is a TupleStruct or Struct and build appropriately
        let type_info = registration.type_info();
        let dynamic_value: Box<dyn PartialReflect> = match type_info {
            bevy::reflect::TypeInfo::TupleStruct(_) => {
                // Build a DynamicTupleStruct with the handle as field 0
                let mut dynamic_tuple = DynamicTupleStruct::default();
                dynamic_tuple.insert_boxed(typed_handle);
                dynamic_tuple.set_represented_type(Some(type_info));
                Box::new(dynamic_tuple)
            }
            bevy::reflect::TypeInfo::Struct(struct_info) => {
                // Handle Struct newtypes (like ImageRenderTarget in Bevy 0.17+)
                // Build a DynamicStruct with named fields
                use bevy::reflect::DynamicStruct;
                
                let mut dynamic_struct = DynamicStruct::default();
                dynamic_struct.set_represented_type(Some(type_info));
                
                // Try to get a default instance of the newtype itself to extract default field values
                // This is the most generic approach - create default, then override the handle field
                let default_instance: Option<Box<dyn Reflect>> = registration
                    .data::<bevy::prelude::ReflectDefault>()
                    .map(|rd| rd.default());
                
                // Find the field that should receive the handle (first Handle<T> field)
                let mut handle_inserted = false;
                
                for field in struct_info.iter() {
                    let field_name = field.name();
                    let field_type_path = field.type_path();
                    
                    // Check if this field is a Handle<T> type - these contain "Handle<"
                    if !handle_inserted && field_type_path.contains("Handle<") {
                        // This is the handle field - insert our typed_handle
                        // Clone the handle using PartialReflect's clone capability
                        if let Ok(cloned) = typed_handle.reflect_clone() {
                            dynamic_struct.insert_boxed(field_name, cloned.into_partial_reflect());
                            handle_inserted = true;
                            debug!("[NEWTYPE_WRAP_REFLECT] Inserted handle into field '{}'", field_name);
                        } else {
                            debug!("[NEWTYPE_WRAP_REFLECT] âš  Failed to clone handle for field '{}'", field_name);
                        }
                    } else {
                        // For non-handle fields, try to get the value from the default instance
                        if let Some(ref default_inst) = default_instance {
                            // reflect_ref() returns ReflectRef directly
                            let default_field = match default_inst.as_partial_reflect().reflect_ref() {
                                bevy::reflect::ReflectRef::Struct(s) => s.field(field_name),
                                _ => None,
                            };
                            
                            if let Some(field_value) = default_field {
                                if let Ok(cloned) = field_value.reflect_clone() {
                                    dynamic_struct.insert_boxed(field_name, cloned.into_partial_reflect());
                                    debug!("[NEWTYPE_WRAP_REFLECT] Copied default value for field '{}': {}", 
                                        field_name, field_type_path);
                                }
                            }
                        } else {
                            // Fall back to trying ReflectDefault on the field type itself
                            if let Some(field_type_registration) = registry.get(field.type_id()) {
                                if let Some(reflect_default) = field_type_registration.data::<bevy::prelude::ReflectDefault>() {
                                    let default_value = reflect_default.default();
                                    dynamic_struct.insert_boxed(field_name, default_value.into_partial_reflect());
                                    debug!("[NEWTYPE_WRAP_REFLECT] Used ReflectDefault for field '{}': {}", 
                                        field_name, field_type_path);
                                } else if let Some(from_reflect) = field_type_registration.data::<ReflectFromReflect>() {
                                    // Try to create a default via ReflectFromReflect
                                    // First try an empty value, then fall back to common primitives
                                    use bevy::reflect::DynamicTupleStruct;
                                    
                                    // Try approaches in order of preference:
                                    // 1. Empty tuple (works if type has Default impl in FromReflect)
                                    // 2. Tuple with common numeric defaults (1.0, 0, etc.)
                                    let attempts: &[Box<dyn PartialReflect>] = &[
                                        Box::new(DynamicTupleStruct::default()),
                                        Box::new({ let mut t = DynamicTupleStruct::default(); t.insert(1.0f32); t }),
                                        Box::new({ let mut t = DynamicTupleStruct::default(); t.insert(0.0f32); t }),
                                        Box::new({ let mut t = DynamicTupleStruct::default(); t.insert(1i32); t }),
                                        Box::new({ let mut t = DynamicTupleStruct::default(); t.insert(0i32); t }),
                                    ];
                                    
                                    let mut created = false;
                                    for attempt in attempts {
                                        if let Some(default_value) = from_reflect.from_reflect(attempt.as_ref()) {
                                            dynamic_struct.insert_boxed(field_name, default_value.into_partial_reflect());
                                            debug!("[NEWTYPE_WRAP_REFLECT] Created default via FromReflect for field '{}': {}", 
                                                field_name, field_type_path);
                                            created = true;
                                            break;
                                        }
                                    }
                                    
                                    if !created {
                                        // Last resort: skip field and let from_reflect use target's Default
                                        debug!("[NEWTYPE_WRAP_REFLECT] âš  Skipping field '{}', hoping from_reflect fills default: {}", 
                                            field_name, field_type_path);
                                    }
                                } else {
                                    debug!("[NEWTYPE_WRAP_REFLECT] âš  No default mechanism for field '{}': {}", 
                                        field_name, field_type_path);
                                }
                            }
                        }
                    }
                }
                
                if !handle_inserted {
                    debug!("[NEWTYPE_WRAP_REFLECT] âœ— No Handle<T> field found in struct '{}'", newtype_type_path);
                    return None;
                }
                
                debug!("[NEWTYPE_WRAP_REFLECT] Built DynamicStruct for '{}' with {} fields", 
                    newtype_type_path, struct_info.field_len());
                
                Box::new(dynamic_struct)
            }
            _ => {
                debug!("[NEWTYPE_WRAP_REFLECT] âœ— Type '{}' is neither TupleStruct nor Struct, unsupported: {:?}", 
                    newtype_type_path, type_info);
                return None;
            }
        };
        
        // Use from_reflect to create the concrete newtype
        match reflect_from_reflect.from_reflect(dynamic_value.as_ref()) {
            Some(concrete) => {
                debug!("[NEWTYPE_WRAP_REFLECT] âœ“ Auto-discovered newtype wrapper for '{}' via reflection", newtype_type_path);
                
                // Cache the successful discovery
                self.discovered_newtype_cache.lock().unwrap().insert(newtype_type_path.to_string());
                
                Some(concrete.into_partial_reflect())
            }
            None => {
                debug!("[NEWTYPE_WRAP_REFLECT] âœ— ReflectFromReflect::from_reflect failed for '{}'", newtype_type_path);
                None
            }
        }
    }

    /// Try to add an asset using registered asset adders (fully generic)
    /// Returns Some(UntypedHandle) if successful, None if no adder registered for type
    pub fn try_add_asset(
        &self,
        world: &mut World,
        type_name: &str,
        asset: &dyn Reflect,
    ) -> Option<UntypedHandle> {
        // Check if adder exists (must drop lock before calling since adder takes &mut World)
        let has_adder = self.asset_adders.lock().unwrap().contains_key(type_name);
        
        if has_adder {
            debug!("[ASSET_ADD] âœ“ Found adder for '{}'", type_name);
            // Re-acquire lock and call the adder
            // This is safe because the adder function captures no state from the registry
            let adders = self.asset_adders.lock().unwrap();
            if let Some(adder) = adders.get(type_name) {
                return adder(world, asset);
            }
        } else {
            let adders = self.asset_adders.lock().unwrap();
            debug!("[ASSET_ADD] âœ— No adder found for '{}'. Registered adders: {:?}", 
                type_name, adders.keys().collect::<Vec<_>>());
        }
        None
    }
    
    /// Try to add an asset using registered cloners (uses &dyn Any for proper downcasting)
    /// This approach preserves non-Reflect data (like Mesh vertex attributes)
    /// Returns Some(UntypedHandle) if successful, None if no cloner registered for type
    pub fn try_clone_and_add_asset(
        &self,
        world: &mut World,
        type_id: std::any::TypeId,
        asset: &dyn std::any::Any,
    ) -> Option<UntypedHandle> {
        // Check if cloner exists (must drop lock before calling since cloner takes &mut World)
        let has_cloner = self.asset_cloners_by_typeid.lock().unwrap().contains_key(&type_id);
        
        if has_cloner {
            debug!("[ASSET_CLONE] âœ“ Found cloner for TypeId {:?}", type_id);
            let cloners = self.asset_cloners_by_typeid.lock().unwrap();
            if let Some(cloner) = cloners.get(&type_id) {
                return cloner(world, asset);
            }
        } else {
            trace!("[ASSET_CLONE] âœ— No cloner registered for TypeId {:?}", type_id);
        }
        None
    }
    
    /// Register an image handle (for load_asset)
    pub fn register_image(&self, handle: Handle<Image>) -> u32 {
        let id = self.next_id.fetch_add(1, Ordering::Relaxed);
        self.image_handles.lock().unwrap().insert(id, handle);
        id
    }
    
    /// Get an image handle by ID
    pub fn get_image_handle(&self, id: u32) -> Option<Handle<Image>> {
        self.image_handles.lock().unwrap().get(&id).cloned()
    }
    
    /// Register a typed asset handle (stores as UntypedHandle for any asset type)
    pub fn register_typed_handle(&self, id: u32, handle: UntypedHandle) {
        self.typed_handles.lock().unwrap().insert(id, handle);
    }
    
    /// Get a typed asset handle by ID and convert to specific type
    pub fn get_typed_handle<T: bevy::asset::Asset>(&self, id: u32) -> Option<Handle<T>> {
        let handles = self.typed_handles.lock().unwrap();
        let untyped_handle = handles.get(&id)?;
        Some(untyped_handle.clone().typed())
    }
    
    /// Get an untyped handle by ID (most generic - works for any asset type)
    pub fn get_untyped_handle(&self, id: u32) -> Option<UntypedHandle> {
        self.typed_handles.lock().unwrap().get(&id).cloned()
    }
    
    /// Register a pending asset for creation
    pub fn register_pending_asset(&self, pending: PendingAsset) -> u32 {
        let id = self.next_id.fetch_add(1, Ordering::Relaxed);
        self.pending_assets.lock().unwrap().insert(id, pending);
        id
    }
    
    /// Register a created asset handle
    pub fn register_asset_handle(&self, id: u32, type_name: String, asset_id: UntypedAssetId) {
        self.asset_handles.lock().unwrap().insert(id, (type_name, asset_id));
    }
    
    /// Get an asset handle by ID
    pub fn get_asset_handle(&self, id: u32) -> Option<(String, UntypedAssetId)> {
        self.asset_handles.lock().unwrap().get(&id).cloned()
    }
    
    /// Drain pending assets
    pub fn drain_pending_assets(&self) -> Vec<(u32, PendingAsset)> {
        let mut pending = self.pending_assets.lock().unwrap();
        pending.drain().collect()
    }
    
    /// Register an asset constructor function (called by generated code)
    /// This allows generated create_X_from_lua functions to be used by process_pending_assets
    pub fn register_asset_constructor<F>(&self, type_name: &str, constructor: F)
    where
        F: Fn(&mlua::Table) -> LuaResult<Box<dyn Reflect>> + Send + Sync + 'static,
    {
        self.asset_constructors
            .lock()
            .unwrap()
            .insert(type_name.to_string(), Box::new(constructor));
    }
    
    /// Try to get a registered asset constructor
    pub fn get_asset_constructor(&self, type_name: &str) -> Option<Box<dyn Fn(&mlua::Table) -> LuaResult<Box<dyn Reflect>> + Send + Sync>> {
        // Clone the Arc to avoid holding the lock
        let constructors = self.asset_constructors.lock().unwrap();
        // We can't clone Box<dyn Fn...>, so we need to return None if not found
        // For now, check if it exists
        if constructors.contains_key(type_name) {
            None // Can't clone - need different approach
        } else {
            None
        }
    }
    
    /// Check if an asset constructor is registered and call it
    pub fn try_construct_asset(&self, type_name: &str, table: &mlua::Table) -> Option<LuaResult<Box<dyn Reflect>>> {
        let constructors = self.asset_constructors.lock().unwrap();
        if let Some(constructor) = constructors.get(type_name) {
            Some(constructor(table))
        } else {
            None
        }
    }
}

/// System to process pending assets and create them via reflection
pub fn process_pending_assets(world: &mut World) {
    // Get resources we need
    let type_registry = world.resource::<AppTypeRegistry>().clone();
    let asset_registry = world.resource::<AssetRegistry>().clone();
    let lua_ctx = world.resource::<crate::lua_integration::LuaScriptContext>().clone();
    
    // Get BitflagsRegistry if available (optional - for generic bitflags handling)
    let bitflags_registry = world.get_resource::<crate::bitflags_registry::BitflagsRegistry>().cloned();
    
    let mut pending = asset_registry.drain_pending_assets();
    
    if pending.is_empty() {
        return;
    }
    
    // CRITICAL: Sort by ID to ensure assets are processed in creation order!
    // HashMap iteration is unordered, so Material (ID 2) could be processed before Image (ID 0)
    // which would cause base_color_texture lookup to fail.
    pending.sort_by_key(|(id, _)| *id);
    
    for (id, pending_asset) in pending {
        let registry = type_registry.read();
        
        // Find the type registration
        if let Some(registration) = registry.get_with_type_path(&pending_asset.type_name) {
            // Check if it has ReflectAsset
            if let Some(reflect_asset) = registration.data::<ReflectAsset>() {
                // Special handling for Mesh - convert primitives to mesh
                let asset_result = if pending_asset.type_name == "bevy_mesh::mesh::Mesh" {
                    debug!("[ASSET_PROCESS] Processing Mesh asset, ID {}", id);
                    match create_mesh_from_primitive(&pending_asset.data, &lua_ctx.lua, &type_registry) {
                        Ok(mesh) => {
                            if let Some(mesh_ref) = mesh.as_reflect().downcast_ref::<Mesh>() {
                                debug!("[ASSET_PROCESS] Mesh created successfully, vertices: {}", mesh_ref.count_vertices());
                            } else {
                                debug!("[ASSET_PROCESS] Mesh created, but downcast to Mesh failed!");
                            }
                            Some(mesh)
                        },
                        Err(e) => {
                            error!("Failed to create mesh from primitive: {}", e);
                            None
                        }
                    }
                } else {
                    // Try registered asset constructor first (for generated bindings like Image)
                    let constructor_result: Option<LuaResult<Box<dyn Reflect>>> = {
                        if let Ok(lua_value) = lua_ctx.lua.registry_value::<LuaValue>(&pending_asset.data) {
                            if let LuaValue::Table(table) = lua_value {
                                asset_registry.try_construct_asset(&pending_asset.type_name, &table)
                            } else {
                                None
                            }
                        } else {
                            None
                        }
                    };
                    
                    if let Some(result) = constructor_result {
                        debug!("[ASSET_PROCESS] Using registered constructor for {}", pending_asset.type_name);
                        match result {
                            Ok(asset) => Some(asset),
                            Err(e) => {
                                error!("Asset constructor failed for {}: {}", pending_asset.type_name, e);
                                None
                            }
                        }
                    } else if let Some(reflect_default) = registration.data::<ReflectDefault>() {
                        // Use Default if available
                        let mut asset = reflect_default.default();
                        debug!("[ASSET_PROCESS] Created default for {}, now populating from Lua", pending_asset.type_name);
                        
                        // Populate fields from Lua data (with handle resolution!)
                        if let Err(e) = populate_asset_from_lua(
                            asset.as_partial_reflect_mut(),
                            &pending_asset.data,
                            &lua_ctx.lua,
                            &asset_registry,
                        ) {
                            error!("Failed to populate asset {}: {}", pending_asset.type_name, e);
                            continue;
                        }
                        
                        Some(asset)
                    } else {
                        // Try to construct from Lua data directly using reflection
                        match construct_asset_from_lua(
                            registration,
                            &pending_asset.data,
                            &lua_ctx.lua,
                            &type_registry,
                        ) {
                            Ok(asset) => Some(asset),
                            Err(e) => {
                                error!("Failed to construct asset {}: {}", pending_asset.type_name, e);
                                None
                            }
                        }
                    }
                };
                
                if let Some(mut asset) = asset_result {
                    // Generic post-construction: apply any bitflags fields from Lua table
                    // Uses BitflagsRegistry for generic type detection and value mapping
                    if let Ok(lua_value) = lua_ctx.lua.registry_value::<LuaValue>(&pending_asset.data) {
                        if let LuaValue::Table(ref t) = lua_value {
                            apply_post_construction_bitflags(
                                asset.as_mut(),
                                t,
                                &pending_asset.type_name,
                                bitflags_registry.as_ref(),
                            );
                            
                            // SPECIAL CASE: Image texture_usages - wgpu types don't support Bevy reflection
                            // so we need to manually set texture_descriptor.usage
                            if pending_asset.type_name == "bevy_image::image::Image" {
                                if let Some(image) = asset.as_any_mut().downcast_mut::<Image>() {
                                    if let Ok(usages_str) = t.get::<String>("texture_usages") {
                                        let flags: Vec<&str> = usages_str.split('|').map(|s| s.trim()).collect();
                                        let mut usage_bits = 0u32;
                                        for flag in flags {
                                            match flag {
                                                "COPY_SRC" => usage_bits |= 1,
                                                "COPY_DST" => usage_bits |= 2,
                                                "TEXTURE_BINDING" => usage_bits |= 4,
                                                "STORAGE_BINDING" => usage_bits |= 8,
                                                "RENDER_ATTACHMENT" => usage_bits |= 16,
                                                _ => warn!("[IMAGE] Unknown texture usage: {}", flag),
                                            }
                                        }
                                        image.texture_descriptor.usage = TextureUsages::from_bits_truncate(usage_bits);
                                        debug!("[IMAGE] âœ“ Set texture_usages to {:?}", image.texture_descriptor.usage);
                                    }
                                }
                            }
                        }
                    }
                    
                    // Priority order for asset addition:
                    // 1. Try ReflectDirectAssetAdd from TypeRegistry (uses as_any() downcasting - preserves ALL data)
                    // 2. Try registered cloners from AssetRegistry (same mechanism but manually registered)
                    // 3. Try registered adders (uses reflection - may lose some data)
                    // 4. Fall back to reflect_asset.add() (uses FromReflect - may lose non-Reflect data)
                    let asset_type_id = asset.as_any().type_id();
                    
                    // First try ReflectDirectAssetAdd type data from the registry
                    let untyped_handle = if let Some(direct_add) = registration.data::<ReflectDirectAssetAdd>() {
                        if let Some(handle) = direct_add.add(asset.as_any(), world) {
                            debug!("[ASSET_PROCESS] âœ“ Used ReflectDirectAssetAdd for {} (preserves ALL data)", pending_asset.type_name);
                            handle
                        } else {
                            debug!("[ASSET_PROCESS] ReflectDirectAssetAdd downcast failed for {}, trying fallbacks", pending_asset.type_name);
                            // Continue to next fallback
                            if let Some(handle) = asset_registry.try_clone_and_add_asset(world, asset_type_id, asset.as_any()) {
                                debug!("[ASSET_PROCESS] âœ“ Used registered cloner for {}", pending_asset.type_name);
                                handle
                            } else if let Some(handle) = asset_registry.try_add_asset(world, &pending_asset.type_name, asset.as_ref()) {
                                debug!("[ASSET_PROCESS] Used registered adder for {}", pending_asset.type_name);
                                handle
                            } else {
                                debug!("[ASSET_PROCESS] No cloner/adder registered, using reflect_asset.add for {}", pending_asset.type_name);
                                reflect_asset.add(world, asset.as_partial_reflect())
                            }
                        }
                    } else if let Some(handle) = asset_registry.try_clone_and_add_asset(world, asset_type_id, asset.as_any()) {
                        debug!("[ASSET_PROCESS] âœ“ Used registered cloner for {} (preserves non-Reflect data)", pending_asset.type_name);
                        handle
                    } else if let Some(handle) = asset_registry.try_add_asset(world, &pending_asset.type_name, asset.as_ref()) {
                        debug!("[ASSET_PROCESS] Used registered adder for {}", pending_asset.type_name);
                        handle
                    } else {
                        // Fall back to generic reflection (may lose non-Reflect field data)
                        debug!("[ASSET_PROCESS] No cloner/adder registered, using reflect_asset.add for {}", pending_asset.type_name);
                        reflect_asset.add(world, asset.as_partial_reflect())
                    };
                    
                    debug!("[ASSET_PROCESS] Asset {} added, handle ID: {:?}", pending_asset.type_name, untyped_handle.id());
                    
                    // Register both the untyped handle (for generic access) and ID
                    asset_registry.register_typed_handle(id, untyped_handle.clone());
                    asset_registry.register_asset_handle(id, pending_asset.type_name.clone(), untyped_handle.id());
                    
                    debug!("âœ“ Created asset {} with ID {} -> Handle {:?}", pending_asset.type_name, id, untyped_handle.id());
                }
            } else {
                error!("Type {} is not an asset (missing ReflectAsset)", pending_asset.type_name);
            }
        } else {
            error!("Asset type not found: {}", pending_asset.type_name);
            error!("Available asset types in registry: {:?}", 
                registry.iter()
                    .filter(|r| r.data::<ReflectAsset>().is_some())
                    .map(|r| r.type_info().type_path())
                    .collect::<Vec<_>>()
            );
        }
    }
}

/// Create a Mesh from primitive shape data using reflection (generic for any primitive type)
fn create_mesh_from_primitive(
    registry_key: &RegistryKey,
    lua: &Lua,
    type_registry: &AppTypeRegistry,
) -> LuaResult<Box<dyn Reflect>> {
    use bevy::prelude::Mesh;
    use bevy::reflect::{ReflectFromReflect, DynamicStruct};
    use bevy::prelude::ReflectDefault;
    
    // Get the Lua value
    let lua_value: LuaValue = lua.registry_value(registry_key)?;
    let data_table = match lua_value {
        LuaValue::Table(t) => t,
        _ => return Err(LuaError::RuntimeError("Mesh data must be a table".to_string())),
    };
    
    // Look for "primitive" field with shape data
    let primitive_value: LuaValue = data_table.get("primitive")?;
    let primitive_table = match primitive_value {
        LuaValue::Table(t) => t,
        _ => return Err(LuaError::RuntimeError("Mesh must have 'primitive' field".to_string())),
    };
    
    // Get the shape variant (e.g., "Cuboid", "Sphere", "Circle")
    let pairs: Vec<(String, LuaValue)> = primitive_table
        .pairs()
        .collect::<LuaResult<_>>()?;
    
    if pairs.is_empty() {
        return Err(LuaError::RuntimeError("Primitive must specify a shape".to_string()));
    }
    
    let (shape_name, shape_data) = &pairs[0];
    
    // Build the full type path for the primitive
    let primitive_type_path = format!("bevy_math::primitives::dim3::{}", shape_name);
    
    debug!("[MESH_GEN] Looking up primitive type: {}", primitive_type_path);
    
    // Get type registration from registry
    let registry = type_registry.read();
    let registration = registry.get_with_type_path(&primitive_type_path)
        .ok_or_else(|| LuaError::RuntimeError(
            format!("Primitive type not found: {}. Available primitives in registry: {:?}", 
                primitive_type_path,
                registry.iter()
                    .filter(|r| r.type_info().type_path().contains("bevy_math::primitives"))
                    .map(|r| r.type_info().type_path())
                    .collect::<Vec<_>>()
            )
        ))?;
    
    debug!("[MESH_GEN] Found primitive type registration");
    
    // Create instance using reflection
    let mut primitive_instance = if let Some(reflect_default) = registration.data::<ReflectDefault>() {
        // Use default constructor if available
        debug!("[MESH_GEN] Creating primitive using ReflectDefault");
        reflect_default.default()
    } else if let Some(reflect_from_reflect) = registration.data::<ReflectFromReflect>() {
        // Try to construct from a dynamic struct
        debug!("[MESH_GEN] Creating primitive using ReflectFromReflect");
        let mut dynamic_struct = DynamicStruct::default();
        dynamic_struct.set_represented_type(Some(registration.type_info()));
        
        reflect_from_reflect.from_reflect(&dynamic_struct)
            .ok_or_else(|| LuaError::RuntimeError(
                format!("Failed to create primitive {} from reflection", shape_name)
            ))?
    } else {
        return Err(LuaError::RuntimeError(
            format!("Primitive type {} doesn't support Default or FromReflect", shape_name)
        ));
    };
    
    // Populate fields from Lua data using generic reflection
    if let LuaValue::Table(ref data_table) = shape_data {
        println!("[MESH_GEN] Populating primitive fields from Lua data");
        
        if let bevy::reflect::ReflectMut::Struct(struct_mut) = primitive_instance.reflect_mut() {
            // Iterate through all fields in the struct
            for i in 0..struct_mut.field_len() {
                // Clone the name to avoid holding an immutable borrow while we need a mutable one later
                let field_name = struct_mut.name_at(i).map(|s| s.to_string());
                
                if let Some(name) = field_name {
                    // Try to get value from Lua table
                    if let Ok(lua_val) = data_table.get::<LuaValue>(name.clone()) {
                        if let Some(field) = struct_mut.field_at_mut(i) {
                            debug!("[MESH_GEN]   Setting field '{}' from Lua", name);
                            set_basic_field(field, &lua_val, None)?;
                        }
                    }
                }
            }
        }
    }
    
    debug!("[MESH_GEN] Converting primitive {} to Mesh", shape_name);
    
    // Convert the primitive to a Mesh using Into<Mesh>
    // We need to downcast to the concrete primitive type and call .into()
    // Since we can't do this generically, we'll use the type path to match
    let mesh: Mesh = match shape_name.as_str() {
        "Cuboid" => {
            use bevy::math::primitives::Cuboid;
            if let Some(cuboid) = primitive_instance.downcast_ref::<Cuboid>() {
                (*cuboid).into()
            } else {
                return Err(LuaError::RuntimeError("Failed to downcast to Cuboid".to_string()));
            }
        }
        "Sphere" => {
            use bevy::math::primitives::Sphere;
            if let Some(sphere) = primitive_instance.downcast_ref::<Sphere>() {
                (*sphere).into()
            } else {
                return Err(LuaError::RuntimeError("Failed to downcast to Sphere".to_string()));
            }
        }
        "Cylinder" => {
            use bevy::math::primitives::Cylinder;
            if let Some(cylinder) = primitive_instance.downcast_ref::<Cylinder>() {
                (*cylinder).into()
            } else {
                return Err(LuaError::RuntimeError("Failed to downcast to Cylinder".to_string()));
            }
        }
        "Capsule3d" => {
            use bevy::math::primitives::Capsule3d;
            if let Some(capsule) = primitive_instance.downcast_ref::<Capsule3d>() {
                (*capsule).into()
            } else {
                return Err(LuaError::RuntimeError("Failed to downcast to Capsule3d".to_string()));
            }
        }
        "Plane3d" => {
            use bevy::math::primitives::Plane3d;
            if let Some(plane) = primitive_instance.downcast_ref::<Plane3d>() {
                (*plane).into()
            } else {
                return Err(LuaError::RuntimeError("Failed to downcast to Plane3d".to_string()));
            }
        }
        "Torus" => {
            use bevy::math::primitives::Torus;
            if let Some(torus) = primitive_instance.downcast_ref::<Torus>() {
                (*torus).into()
            } else {
                return Err(LuaError::RuntimeError("Failed to downcast to Torus".to_string()));
            }
        }
        _ => {
            return Err(LuaError::RuntimeError(
                format!("Primitive type {} doesn't support conversion to Mesh. Supported: Cuboid, Sphere, Cylinder, Capsule3d, Plane3d, Torus", shape_name)
            ));
        }
    };
    
    // Log what attributes the mesh has
    debug!("[MESH_GEN] Created {} mesh with {} vertices", shape_name, mesh.count_vertices());
    debug!("[MESH_GEN] Topology: {:?}", mesh.primitive_topology());
    debug!("[MESH_GEN] Has POSITION: {}", mesh.attribute(Mesh::ATTRIBUTE_POSITION).is_some());
    debug!("[MESH_GEN] Has NORMAL: {}", mesh.attribute(Mesh::ATTRIBUTE_NORMAL).is_some());
    debug!("[MESH_GEN] Has UV_0: {}", mesh.attribute(Mesh::ATTRIBUTE_UV_0).is_some());
    debug!("[MESH_GEN] Has TANGENT: {}", mesh.attribute(Mesh::ATTRIBUTE_TANGENT).is_some());
    
    // Generate tangents if missing (required for PBR prepass with shadows)
    // Tangent generation requires: TriangleList topology, POSITION, NORMAL, UV_0
    let mut mesh = mesh;
    if mesh.attribute(Mesh::ATTRIBUTE_TANGENT).is_none() {
        debug!("[MESH_GEN] Tangents missing, attempting to generate...");
        
        // Check prerequisites for tangent generation
        let has_prerequisites = mesh.attribute(Mesh::ATTRIBUTE_POSITION).is_some()
            && mesh.attribute(Mesh::ATTRIBUTE_NORMAL).is_some()
            && mesh.attribute(Mesh::ATTRIBUTE_UV_0).is_some();
        
        if !has_prerequisites {
            debug!("[MESH_GEN] WARNING: Cannot generate tangents - missing required attributes");
            debug!("[MESH_GEN]   Required: POSITION, NORMAL, UV_0");
            debug!("[MESH_GEN]   This mesh may not render correctly with PBR materials that use normal maps");
        } else {
            // Attempt to generate tangents
            // generate_tangents() will return an error if prerequisites aren't met (e.g. wrong topology)
            match mesh.generate_tangents() {
                Ok(()) => {
                    debug!("[MESH_GEN] âœ“ Tangents generated successfully");
                }
                Err(e) => {
                    debug!("[MESH_GEN] ERROR: Failed to generate tangents: {:?}", e);
                    debug!("[MESH_GEN]   The mesh may not render correctly with shadows or normal maps");
                    debug!("[MESH_GEN]   Consider using an unlit material or disabling shadows");
                }
            }
        }
    } else {
        debug!("[MESH_GEN] Tangents already present");
    }
    
    Ok(Box::new(mesh))
}

/// Construct an asset from Lua data without Default (using FromReflect)
fn construct_asset_from_lua(
    registration: &TypeRegistration,
    registry_key: &RegistryKey,
    lua: &Lua,
    _type_registry: &AppTypeRegistry,
) -> LuaResult<Box<dyn Reflect>> {
    use bevy::reflect::{DynamicStruct, ReflectFromReflect};
    
    // Get the Lua value from registry
    let lua_value: LuaValue = lua.registry_value(registry_key)?;
    
    // Must be a table
    let data_table = match lua_value {
        LuaValue::Table(t) => t,
        _ => return Err(LuaError::RuntimeError("Asset data must be a table".to_string())),
    };
    
    // Get type info
    let type_info = registration.type_info();
    
    // Create a dynamic struct
    let mut dynamic_struct = DynamicStruct::default();
    dynamic_struct.set_represented_type(Some(type_info));
    
    // Get the AssetRegistry for handle conversion
    let asset_registry = lua.globals().get::<LuaTable>("__asset_registry")
        .ok()
        .and_then(|t| t.raw_get::<mlua::AnyUserData>("ptr").ok())
        .and_then(|ud| ud.borrow::<Arc<AssetRegistry>>().ok().map(|r| r.clone()));
    
    // Populate fields from Lua table
    for pair in data_table.pairs::<String, LuaValue>() {
        let (field_name, field_value) = pair?;
        
        // Try to create the field value
        if let Some(value) = try_create_value_from_lua(field_value, asset_registry.as_deref())? {
            dynamic_struct.insert_boxed(&field_name, value);
        }
    }
    
    // Convert to concrete type via FromReflect
    let reflect_from_reflect = registration.data::<ReflectFromReflect>()
        .ok_or_else(|| LuaError::RuntimeError(
            format!("Asset type {} doesn't implement FromReflect", registration.type_info().type_path())
        ))?;
    
    let asset = reflect_from_reflect.from_reflect(&dynamic_struct)
        .ok_or_else(|| LuaError::RuntimeError(
            format!("Failed to create asset {} from reflection", registration.type_info().type_path())
        ))?;
    
    Ok(asset)
}

/// Helper to convert Lua values to reflection values
fn try_create_value_from_lua(
    lua_value: LuaValue,
    asset_registry: Option<&AssetRegistry>,
) -> LuaResult<Option<Box<dyn PartialReflect>>> {
    use bevy::reflect::{DynamicStruct, DynamicEnum, DynamicVariant};
    
    match lua_value {
        LuaValue::Boolean(b) => Ok(Some(Box::new(b))),
        LuaValue::Integer(i) => Ok(Some(Box::new(i as i32))),
        LuaValue::Number(n) => Ok(Some(Box::new(n as f32))),
        LuaValue::String(s) => Ok(Some(Box::new(s.to_str()?.to_string()))),
        LuaValue::Table(t) => {
            // Check if it's an enum (single key-value where value is a table)
            let pairs: Vec<_> = t.clone().pairs::<String, LuaValue>().collect::<LuaResult<_>>()?;
            
            if pairs.len() == 1 {
                let (key, value) = &pairs[0];
                
                // Check for asset handle (numeric ID) - skip for now, needs type parameter
                if key == "asset_id" {
                    // Can't create typed handles without knowing the asset type at compile time
                    // This would need special handling or a different approach
                }
                
                // Try as enum variant
                if let LuaValue::Table(variant_data) = value {
                    let mut dynamic_struct = DynamicStruct::default();
                    
                    for pair in variant_data.pairs::<String, LuaValue>() {
                        let (field_name, field_value) = pair?;
                        if let Some(nested_value) = try_create_value_from_lua(field_value, asset_registry)? {
                            dynamic_struct.insert_boxed(&field_name, nested_value);
                        }
                    }
                    
                    let dynamic_enum = DynamicEnum::new(key, DynamicVariant::Struct(dynamic_struct));
                    return Ok(Some(Box::new(dynamic_enum)));
                }
            }
            
            // Regular struct
            let mut dynamic_struct = DynamicStruct::default();
            
            for pair in t.pairs::<String, LuaValue>() {
                let (field_name, field_value) = pair?;
                if let Some(nested_value) = try_create_value_from_lua(field_value, asset_registry)? {
                    dynamic_struct.insert_boxed(&field_name, nested_value);
                }
            }
            
            Ok(Some(Box::new(dynamic_struct)))
        }
        _ => Ok(None),
    }
}

/// Populate asset fields from Lua data
fn populate_asset_from_lua(
    asset: &mut dyn PartialReflect,
    registry_key: &RegistryKey,
    lua: &Lua,
    asset_registry: &AssetRegistry,  // Added to resolve handle IDs!
) -> LuaResult<()> {
    // Get the Lua value from registry
    let lua_value: LuaValue = lua.registry_value(registry_key)?;
    
    // Must be a table
    let data_table = match lua_value {
        LuaValue::Table(t) => t,
        _ => return Err(LuaError::RuntimeError("Asset data must be a table".to_string())),
    };
    
    // Get struct reflection
    let reflect_result = asset.reflect_mut();
    debug!("[ASSET_POPULATE] ReflectMut variant: {:?}", match &reflect_result {
        bevy::reflect::ReflectMut::Struct(_) => "Struct",
        bevy::reflect::ReflectMut::TupleStruct(_) => "TupleStruct",
        bevy::reflect::ReflectMut::Tuple(_) => "Tuple",
        bevy::reflect::ReflectMut::List(_) => "List",
        bevy::reflect::ReflectMut::Array(_) => "Array",
        bevy::reflect::ReflectMut::Map(_) => "Map",
        bevy::reflect::ReflectMut::Set(_) => "Set",
        bevy::reflect::ReflectMut::Enum(_) => "Enum",
        bevy::reflect::ReflectMut::Opaque(_) => "Opaque",
    });
    if let bevy::reflect::ReflectMut::Struct(struct_mut) = reflect_result {
        debug!("[ASSET_POPULATE] Struct has {} fields", struct_mut.field_len());
        // Iterate through fields - collect names first to avoid borrow issues
        for i in 0..struct_mut.field_len() {
            // Copy name before getting mutable reference
            let field_name_opt = struct_mut.name_at(i).map(|s| s.to_string());
            if let Some(field_name) = field_name_opt {
                debug!("[ASSET_POPULATE] Field {}: '{}'", i, field_name);
                // Try to get value from Lua table
                if let Ok(lua_val) = data_table.get::<LuaValue>(&*field_name) {
                    debug!("[ASSET_POPULATE]   Found Lua value for '{}': {:?}", field_name, lua_val);
                    if let Some(field) = struct_mut.field_at_mut(i) {
                        let type_path = field.reflect_type_path().to_string();
                        
                        // Check if this is a handle field (Option<Handle<T>> or Handle<T>)
                        // Look for Lua integers which are asset IDs that need to be resolved
                        if let LuaValue::Integer(asset_id) = &lua_val {
                            // This is an asset ID - try to resolve to a handle using registered setters
                            if type_path.contains("Handle<") {
                                debug!("[ASSET_POPULATE] Found handle field '{}' (type: {}) with ID {}", field_name, type_path, asset_id);
                                if let Some(handle) = asset_registry.get_untyped_handle(*asset_id as u32) {
                                    if asset_registry.try_set_handle_field(field, &type_path, handle.clone()) {
                                        debug!("[ASSET_POPULATE] âœ“ Set {} via registered handle setter", field_name);
                                        continue;
                                    } else {
                                        debug!("[ASSET_POPULATE] âš  No handle setter registered for type: {}", type_path);
                                    }
                                } else {
                                    debug!("[ASSET_POPULATE] âœ— No handle found in registry for ID {}", asset_id);
                                }
                            }
                        }
                        
                        // Fall back to basic type handling
                        set_basic_field(field, &lua_val, None)?;
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Set field types from Lua values using pure reflection (fully generic)
/// Now supports bitflags via registry lookup for strings containing |
fn set_basic_field(
    field: &mut dyn PartialReflect, 
    lua_value: &LuaValue,
    bitflags_registry: Option<&crate::bitflags_registry::BitflagsRegistry>,
) -> LuaResult<()> {
    use bevy::reflect::ReflectMut;
    
    match lua_value {
        LuaValue::Integer(v) => {
            // Try to apply integer to any numeric type via reflection
            // Use try_downcast_mut for value types (primitives)
            if let Some(f32_field) = field.try_downcast_mut::<f32>() {
                *f32_field = *v as f32;
            } else if let Some(u32_field) = field.try_downcast_mut::<u32>() {
                *u32_field = *v as u32;
            } else if let Some(i32_field) = field.try_downcast_mut::<i32>() {
                *i32_field = *v as i32;
            } else if let Some(usize_field) = field.try_downcast_mut::<usize>() {
                *usize_field = *v as usize;
            }
        }
        LuaValue::Number(v) => {
            // Try to apply number to any numeric type
            if let Some(f32_field) = field.try_downcast_mut::<f32>() {
                *f32_field = *v as f32;
            } else if let Some(f64_field) = field.try_downcast_mut::<f64>() {
                *f64_field = *v;
            }
        }
        LuaValue::Boolean(v) => {
            if let Some(bool_field) = field.try_downcast_mut::<bool>() {
                *bool_field = *v;
            }
        }
        LuaValue::String(s) => {
            if let Ok(string) = s.to_str() {
                // First, check if this looks like bitflags (contains |)
                if string.contains('|') {
                    let flag_names: Vec<&str> = string.split('|').map(|s| s.trim()).collect();
                    if try_set_bitflags_from_names(field, &flag_names, bitflags_registry) {
                        debug!("[SET_BASIC_FIELD] âœ“ Applied bitflags: {}", string);
                        return Ok(());
                    }
                }
                // Fall back to String field
                if let Some(string_field) = field.try_downcast_mut::<String>() {
                    *string_field = string.to_string();
                }
            }
        }
        LuaValue::Table(table) => {
            // FIRST: Try generic FromReflect construction for ANY reflected type
            if let Ok(true) = try_from_reflect_construction(field, table) {
                return Ok(());
            }
            
            // Generic struct iteration (for structs without FromReflect)
            match field.reflect_mut() {
                ReflectMut::Struct(struct_mut) => {
                    // Iterate through struct fields and populate from table
                    for i in 0..struct_mut.field_len() {
                        if let Some(field_name) = struct_mut.name_at(i) {
                            if let Ok(nested_value) = table.get::<LuaValue>(field_name) {
                                if let Some(nested_field) = struct_mut.field_at_mut(i) {
                                    set_basic_field(nested_field, &nested_value, bitflags_registry)?;
                                }
                            }
                        }
                    }
                }
                _ => {
                    debug!("Lua table for non-struct field type: {:?}", field.reflect_type_path());
                }
            }
        }
        _ => {}
    }
    
    Ok(())
}

/// Helper: Build a dynamic reflect value from a Lua value
/// This is used by FromReflect to construct types generically
/// Now supports nested tables recursively
fn lua_value_to_reflect_value(lua_value: &LuaValue) -> LuaResult<Box<dyn bevy::reflect::PartialReflect>> {
    use bevy::reflect::DynamicStruct;
    
    match lua_value {
        LuaValue::Number(n) => Ok(Box::new(*n as f32)),
        LuaValue::Integer(i) => {
            // Store as i64 for flexibility, reflection will handle conversion
            Ok(Box::new(*i))
        },
        LuaValue::Boolean(b) => Ok(Box::new(*b)),
        LuaValue::String(s) => Ok(Box::new(s.to_str()?.to_owned())),
        LuaValue::Table(table) => {
            // Handle nested tables by creating a DynamicStruct
            let mut dynamic_struct = DynamicStruct::default();
            
            for pair in table.pairs::<String, LuaValue>() {
                let (key, value) = pair?;
                if let Ok(reflect_value) = lua_value_to_reflect_value(&value) {
                    dynamic_struct.insert_boxed(&key, reflect_value);
                }
            }
            
            Ok(Box::new(dynamic_struct))
        },
        _ => Err(LuaError::RuntimeError(format!("Cannot convert {:?} to reflect value", lua_value)))
    }
}

/// Try to construct a field's value using FromReflect from a Lua table
/// This is the GENERIC approach that works for ANY type implementing FromReflect
fn try_from_reflect_construction(
    field: &mut dyn bevy::reflect::PartialReflect,
    table: &mlua::Table,
) -> LuaResult<bool> {
    use bevy::reflect::{DynamicStruct, TypeInfo};
    
    // Get the type info for this field
    let Some(type_info) = field.get_represented_type_info() else {
        return Ok(false);
    };
    
    // Build a dynamic representation based on the type
    match type_info {
        TypeInfo::Struct(struct_info) => {
            let mut dynamic_struct = DynamicStruct::default();
            dynamic_struct.set_represented_type(Some(type_info));
            
            // Populate each field from the Lua table
            for field_info in struct_info.iter() {
                let field_name = field_info.name();
                if let Ok(lua_val) = table.get::<LuaValue>(field_name) {
                    match lua_value_to_reflect_value(&lua_val) {
                        Ok(reflect_val) => {
                            dynamic_struct.insert_boxed(field_name, reflect_val);
                        },
                        Err(_) => {
                            // If we encounter a value we can't convert (like a nested Table),
                            // we must abort generic construction and let the recursive fallback handle it.
                            return Ok(false);
                        }
                    }
                }
            }
            
            // Try to apply the dynamic struct to the field
            field.apply(dynamic_struct.as_partial_reflect());
            Ok(true)
        }
        TypeInfo::TupleStruct(tuple_info) => {
            use bevy::reflect::DynamicTuple;
            let mut dynamic_tuple = DynamicTuple::default();
            
            // Try fields named _0, _1, _2, etc.
            for i in 0..tuple_info.field_len() {
                let field_key = format!("_{}", i);
                if let Ok(lua_val) = table.get::<LuaValue>(field_key.as_str()) {
                    match lua_value_to_reflect_value(&lua_val) {
                        Ok(reflect_val) => {
                            dynamic_tuple.insert_boxed(reflect_val);
                        },
                        Err(_) => {
                            return Ok(false);
                        }
                    }
                }
            }
            
            field.apply(dynamic_tuple.as_partial_reflect());
            Ok(true)
        }
        TypeInfo::Enum(enum_info) => {
            // For enums, the Lua table should have ONE key that matches a variant name
            // e.g., { Image = asset_id } for RenderTarget::Image variant
            
            // Try to find which variant is specified in the table
            for variant_info in enum_info.iter() {
                let variant_name = variant_info.name();
                
                // Check if this variant is in the Lua table
                if let Ok(variant_value) = table.get::<LuaValue>(variant_name) {
                    // Found the variant! Now construct it based on its type
                    match variant_info {
                        bevy::reflect::VariantInfo::Tuple(tuple_variant) => {
                            // Tuple variant like Image(Handle<Image>) or Image(ImageRenderTarget)
                            use bevy::reflect::DynamicEnum;
                            
                            // For single-field tuple variants, the value can be passed directly
                            if tuple_variant.field_len() == 1 {
                                // Get the field's type info directly (no registry needed)
                                let field_info = tuple_variant.field_at(0);
                                let field_type_path = field_info.map(|f| f.type_path().to_string());
                                
                                // Convert the Lua value to a reflected value  
                                let reflected_value = lua_value_to_reflect_value(&variant_value)?;
                                
                                // Check if we need to wrap in a newtype (TupleStruct)
                                // Generic detection: use the field's type_info() to check if it's a TupleStruct with 1 field
                                let is_newtype_wrapper = field_info
                                    .and_then(|f| f.type_info())
                                    .map(|ti| matches!(ti, TypeInfo::TupleStruct(ts) if ts.field_len() == 1))
                                    .unwrap_or(false);
                                
                                let final_value = if is_newtype_wrapper {
                                    debug!("[ENUM_VARIANT] Detected newtype wrapper '{:?}' for variant '{}', auto-wrapping", field_type_path, variant_name);
                                    // Wrap in a DynamicTupleStruct (single-field tuple struct)
                                    let mut dynamic_ts = bevy::reflect::DynamicTupleStruct::default();
                                    dynamic_ts.insert_boxed(reflected_value);
                                    Box::new(dynamic_ts) as Box<dyn bevy::reflect::PartialReflect>
                                } else {
                                    reflected_value
                                };
                                
                                // Create a dynamic tuple with this value (possibly wrapped in newtype)
                                let mut dynamic_tuple = bevy::reflect::DynamicTuple::default();
                                dynamic_tuple.insert_boxed(final_value);
                                
                                // Create the enum variant
                                let dynamic_enum = DynamicEnum::new(variant_name, dynamic_tuple);
                                
                                // Apply to the field
                                field.apply(dynamic_enum.as_partial_reflect());
                                return Ok(true);
                            }
                        }
                        bevy::reflect::VariantInfo::Struct(struct_variant) => {
                            // Struct variant like Something { field1: T1, field2: T2 }
                            use bevy::reflect::{DynamicEnum, DynamicStruct};
                            
                            if let LuaValue::Table(variant_table) = variant_value {
                                let mut variant_struct = DynamicStruct::default();
                                
                                // Populate struct fields
                                for field_info in struct_variant.iter() {
                                    if let Ok(lua_val) = variant_table.get::<LuaValue>(field_info.name()) {
                                        if let Ok(reflect_val) = lua_value_to_reflect_value(&lua_val) {
                                            variant_struct.insert_boxed(field_info.name(), reflect_val);
                                        }
                                    }
                                }
                                
                                let dynamic_enum = DynamicEnum::new(variant_name, variant_struct);
                                field.apply(dynamic_enum.as_partial_reflect());
                                return Ok(true);
                            }
                        }
                        bevy::reflect::VariantInfo::Unit(_unit_variant) => {
                            // Unit variant like None or SomeVariant
                            use bevy::reflect::DynamicEnum;
                            
                            let dynamic_enum = DynamicEnum::new(variant_name, ());
                            field.apply(dynamic_enum.as_partial_reflect());
                            return Ok(true);
                        }
                    }
                }
            }
            
            // No matching variant found
            Ok(false)
        }
        _ => {
            // Other types not yet supported
            Ok(false)
        }
    }
}

/// Add asset loading and creation capabilities to Lua context
pub fn add_asset_loading_to_lua(
    lua_ctx: &crate::lua_integration::LuaScriptContext,
    asset_server: AssetServer,
    asset_registry: AssetRegistry,
) -> Result<(), LuaError> {
    let lua = &lua_ctx.lua;
    
    // load_asset - for loading image files
    let asset_registry_clone = asset_registry.clone();
    let load_asset = lua.create_function(move |_lua_ctx, path: String| {
        let handle: Handle<Image> = asset_server.load(&path);
        let id = asset_registry_clone.register_image(handle);
        Ok(id)
    })?;
    
    // create_asset - generic asset creation via reflection
    let registry_clone = asset_registry.clone();
    let create_asset = lua.create_function(move |lua_ctx, (type_name, data): (String, LuaTable)| {
        // Store the Lua table in registry
        let registry_key = lua_ctx.create_registry_value(data)?;
        
        let pending = PendingAsset {
            type_name,
            data: Arc::new(registry_key),
        };
        
        let id = registry_clone.register_pending_asset(pending);
        Ok(id)
    })?;
    
    // Inject into globals
    lua.globals().set("load_asset", load_asset)?;
    lua.globals().set("create_asset", create_asset)?;
    
    Ok(())
}

/// Apply post-construction bitflags fields from Lua table to the asset
/// Uses BitflagsRegistry for generic type detection and value mapping
/// 
/// The function is fully generic - it iterates Lua table keys, looks for pipe-separated
/// strings (bitflags), and applies them to matching asset fields via the registry.
fn apply_post_construction_bitflags(
    asset: &mut dyn Reflect,
    lua_table: &mlua::Table,
    type_name: &str,
    bitflags_registry: Option<&crate::bitflags_registry::BitflagsRegistry>,
) {
    // Iterate through all Lua table keys to find potential bitflags (pipe-separated strings)
    let Ok(pairs) = lua_table.pairs::<String, mlua::Value>().collect::<mlua::Result<Vec<_>>>() else {
        return;
    };
    
    for (key, value) in pairs {
        // Only process string values containing "|" (likely bitflags)
        let mlua::Value::String(s) = value else { continue };
        let Ok(value_str) = s.to_str() else { continue };
        if !value_str.contains('|') { continue; }
        
        // Parse flag names from the pipe-separated string
        let flag_names: Vec<&str> = value_str.split('|').map(|s| s.trim()).collect();
        
        // Try to apply to a matching nested field path
        // Convert Lua key to potential field names: "texture_usages" -> look for "usage", "usages", etc.
        if apply_bitflags_to_nested_field(asset, &key, &flag_names, type_name, bitflags_registry) {
            debug!("[POST_CONSTRUCTION] âœ“ Applied {} to {}: {}", key, type_name, value_str);
        } else {
            debug!("[POST_CONSTRUCTION] âš  Failed to apply {} to {}: {}", key, type_name, value_str);
        }
    }
}

/// Try to find and apply bitflags to a nested field on the asset via reflection
fn apply_bitflags_to_nested_field(
    asset: &mut dyn Reflect,
    lua_key: &str,
    flag_names: &[&str],
    _type_name: &str,
    bitflags_registry: Option<&crate::bitflags_registry::BitflagsRegistry>,
) -> bool {
    use bevy::reflect::{ReflectMut, PartialReflect};
    
    // Common pattern: "texture_usages" in Lua should set a field containing "usage" 
    // Try to find the field by traversing the asset's structure
    let target_field = lua_key.trim_end_matches('s'); // "texture_usages" -> "texture_usage"
    let target_field_short = target_field.split('_').last().unwrap_or(target_field); // "usage"
    
    // For nested fields like texture_descriptor.usage, we need to traverse
    if let ReflectMut::Struct(s) = asset.reflect_mut() {
        for i in 0..s.field_len() {
            let field_name = s.name_at(i).unwrap_or("");
            
            // Check if this field might contain our target (e.g., "texture_descriptor")
            if field_name.contains("descriptor") || field_name.contains(target_field_short) {
                if let Some(field_ref) = s.field_at_mut(i) {
                    // Try to apply bitflags to this field or its nested "usage" field
                    if try_apply_bitflags_value(field_ref.as_partial_reflect_mut(), target_field_short, flag_names, bitflags_registry) {
                        return true;
                    }
                }
            }
        }
        
        // Also try direct fields
        if let Some(field) = s.field_mut(target_field_short) {
            if try_set_bitflags_from_names(field.as_partial_reflect_mut(), flag_names, bitflags_registry) {
                return true;
            }
        }
    }
    
    // GENERIC FALLBACK: For types with nested fields that aren't Reflect-enabled,
    // we try to set them by first looking for any field with "usage" in the type path
    // The BitflagsRegistry handles the actual value parsing generically
    if let ReflectMut::Struct(s) = asset.reflect_mut() {
        for i in 0..s.field_len() {
            if let Some(field_ref) = s.field_at_mut(i) {
                // Recursively try nested structs
                if let Some(reflect_mut) = field_ref.as_partial_reflect_mut().try_as_reflect_mut() {
                    if let ReflectMut::Struct(nested) = reflect_mut.reflect_mut() {
                        if let Some(usage_field) = nested.field_mut(target_field_short) {
                            if try_set_bitflags_from_names(usage_field.as_partial_reflect_mut(), flag_names, bitflags_registry) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
    }
    
    false
}

/// Try to apply bitflags value to a field or its nested field
fn try_apply_bitflags_value(
    field: &mut dyn PartialReflect,
    target_name: &str,
    flag_names: &[&str],
    bitflags_registry: Option<&crate::bitflags_registry::BitflagsRegistry>,
) -> bool {
    use bevy::reflect::ReflectMut;
    
    // First, check if the field itself is the target
    if try_set_bitflags_from_names(field, flag_names, bitflags_registry) {
        return true;
    }
    
    // If it's a struct, look for nested fields matching target_name
    if let Some(reflect_mut) = field.try_as_reflect_mut() {
        if let ReflectMut::Struct(s) = reflect_mut.reflect_mut() {
            // Look for "usage" field within this struct
            if let Some(nested_field) = s.field_mut(target_name) {
                if try_set_bitflags_from_names(nested_field.as_partial_reflect_mut(), flag_names, bitflags_registry) {
                    return true;
                }
            }
        }
    }
    
    false
}

/// Try to set a bitflags field value from flag names
/// Uses BitflagsRegistry for generic type path detection and value mapping
fn try_set_bitflags_from_names(
    field: &mut dyn PartialReflect,
    flag_names: &[&str],
    bitflags_registry: Option<&crate::bitflags_registry::BitflagsRegistry>,
) -> bool {
    let type_path = field.reflect_type_path();
    
    // Use the bitflags registry if available
    if let Some(registry) = bitflags_registry {
        if let Some(value) = registry.parse_flags(type_path, flag_names) {
            // SAFETY: Bitflags types are wrappers around u32.
            // We set the value directly via pointer since wgpu types don't implement Reflect.
            unsafe {
                let field_ptr = field as *mut dyn PartialReflect as *mut u8;
                let value_ptr = field_ptr as *mut u32;
                *value_ptr = value;
            }
            return true;
        }
    }
    
    // Log unknown bitflags types for debugging
    if type_path.contains("Flags") || type_path.contains("Usage") {
        debug!("[POST_CONSTRUCTION] Unknown bitflags type: {} - register via BitflagsRegistry", type_path);
    }
    
    false
}
