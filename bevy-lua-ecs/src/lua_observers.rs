//! Lua observer system for dispatching Bevy events to Lua callbacks
//! 
//! This module provides the infrastructure for Lua scripts to register observers
//! that are called when Bevy pointer events occur on entities.
//! 
//! Usage in Lua:
//! ```lua
//! spawn({ Button = {} })
//!     :observe("Pointer<Over>", function(entity, event)
//!         entity:set("BackgroundColor", { color = { r = 1.0, g = 0.0, b = 0.0, a = 1.0 } })
//!     end)
//! ```
//!
//! Observer handlers are auto-generated by build.rs based on discovered event types.
//! The consuming crate must call `set_observer_attacher()` with the generated
//! `attach_observer_by_name` function to enable observer attachment.

use bevy::prelude::*;
use mlua::prelude::*;
use std::sync::Arc;
use crate::spawn_queue::SpawnQueue;

/// Function type for attaching observers by name
/// This function is generated by build.rs in the consuming crate
pub type ObserverAttacherFn = fn(&mut Commands, Entity, &str);

/// Global observer attacher function
/// Set by the consuming crate's generated code
static OBSERVER_ATTACHER: std::sync::OnceLock<ObserverAttacherFn> = std::sync::OnceLock::new();

/// Set the observer attacher function (called by consuming crate's generated code)
pub fn set_observer_attacher(attacher: ObserverAttacherFn) {
    let _ = OBSERVER_ATTACHER.set(attacher);
}

/// Get the observer attacher function
fn get_observer_attacher() -> Option<ObserverAttacherFn> {
    OBSERVER_ATTACHER.get().copied()
}

/// Resource storing Lua observer callbacks mapped by Entity
/// Structure: Entity -> Vec<(event_type, LuaRegistryKey)>
#[derive(Resource, Default, Clone)]
pub struct LuaObserverRegistry {
    callbacks: Arc<std::sync::Mutex<std::collections::HashMap<Entity, Vec<(String, LuaRegistryKey)>>>>,
}

impl LuaObserverRegistry {
    /// Register observer callbacks for an entity
    pub fn register(&self, entity: Entity, observers: Vec<(String, LuaRegistryKey)>) {
        if !observers.is_empty() {
            debug!("[LUA_OBSERVER] Registering {} observers for {:?}", observers.len(), entity);
            self.callbacks.lock().unwrap().insert(entity, observers);
        }
    }
    
    /// Take all callbacks (destructive - for cleanup)
    pub fn take_callbacks(&self, entity: Entity) -> Vec<(String, LuaRegistryKey)> {
        self.callbacks.lock().unwrap().remove(&entity).unwrap_or_default()
    }
    
    /// Get access to callbacks (for generated observer handlers)
    pub fn callbacks(&self) -> &Arc<std::sync::Mutex<std::collections::HashMap<Entity, Vec<(String, LuaRegistryKey)>>>> {
        &self.callbacks
    }
}

/// System to process observer registrations from spawn queue
/// Called after entities are spawned to attach Lua observer callbacks
pub fn process_observer_registrations(
    spawn_queue: Res<SpawnQueue>,
    observer_registry: ResMut<LuaObserverRegistry>,
) {
    // Take all observer callbacks from spawn queue
    let all_callbacks = spawn_queue.take_all_observer_callbacks();
    
    for (temp_id, observers) in all_callbacks {
        // Resolve temp_id to actual Entity
        if let Some(entity) = spawn_queue.get_entity(temp_id) {
            observer_registry.register(entity, observers);
        } else {
            warn!("[LUA_OBSERVER] Could not resolve temp_id {} to Entity", temp_id);
        }
    }
}

/// Marker component for entities that have Lua observers attached
#[derive(Component)]
pub struct LuaObserversAttached;

/// Attach observers to entities that have registered Lua callbacks
/// Requires the consuming crate to call `set_observer_attacher()` with the generated
/// `attach_observer_by_name` function.
pub fn attach_lua_observers(
    mut commands: Commands,
    observer_registry: Res<LuaObserverRegistry>,
    entities_with_callbacks: Query<Entity, (With<Node>, Without<LuaObserversAttached>)>,
) {
    let Some(attacher) = get_observer_attacher() else {
        // No attacher registered yet - this is fine during early startup
        return;
    };
    
    let registry = observer_registry.callbacks.lock().unwrap();
    
    for entity in entities_with_callbacks.iter() {
        if let Some(observers) = registry.get(&entity) {
            debug!("[LUA_OBSERVER] Attaching {} observers to {:?}", observers.len(), entity);
            
            // Collect unique event types first
            let event_types: std::collections::HashSet<_> = observers.iter()
                .map(|(event_type, _)| event_type.clone())
                .collect();
            
            // Attach observer for each unique event type using the generated attacher
            for event_type in event_types {
                attacher(&mut commands, entity, &event_type);
            }
            
            // Mark entity as having observers attached
            commands.entity(entity).insert(LuaObserversAttached);
        }
    }
}

/// Internal dispatch function for Lua observer callbacks
/// This is called by the generated observer handlers
pub fn dispatch_lua_observer_internal(
    lua_ctx: &crate::lua_integration::LuaScriptContext,
    observer_registry: &LuaObserverRegistry,
    update_queue: &crate::component_update_queue::ComponentUpdateQueue,
    entity: Entity,
    event_type: &str,
    position: Option<bevy::math::Vec2>,
) {
    let callbacks = observer_registry.callbacks.lock().unwrap();
    
    bevy::log::debug!("[OBSERVER_DISPATCH] Looking for entity {:?}, event '{}', registered entities: {:?}", 
        entity, event_type, callbacks.keys().collect::<Vec<_>>());
    
    if let Some(observers) = callbacks.get(&entity) {
        bevy::log::debug!("[OBSERVER_DISPATCH] Found {} observers for entity {:?}", observers.len(), entity);
        for (ev_type, callback_key) in observers {
            bevy::log::debug!("[OBSERVER_DISPATCH] Checking observer: ev_type='{}' vs event_type='{}'", ev_type, event_type);
            if ev_type == event_type {
                if let Ok(callback) = lua_ctx.lua.registry_value::<LuaFunction>(callback_key) {
                    let entity_snapshot = crate::lua_world_api::LuaEntitySnapshot {
                        entity,
                        component_data: std::collections::HashMap::new(),
                        lua_components: std::collections::HashMap::new(),
                        update_queue: update_queue.clone(),
                    };
                    
                    let event_table = lua_ctx.lua.create_table().unwrap();
                    if let Some(pos) = position {
                        event_table.set("x", pos.x).unwrap();
                        event_table.set("y", pos.y).unwrap();
                    }
                    
                    if let Err(e) = callback.call::<()>((entity_snapshot, event_table)) {
                        error!("[LUA_OBSERVER] Error calling {} callback: {}", event_type, e);
                    }
                }
            }
        }
    }
}
